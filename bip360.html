
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="BIP 360 - Pay to Quantum Resistant Hash" />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 360: Pay to Quantum Resistant Hash" />
    <meta property="og:description" content="BIP 360 - Pay to Quantum Resistant Hash" />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 360: Pay to Quantum Resistant Hash" />
    <meta name="twitter:description" content="BIP 360 - Pay to Quantum Resistant Hash" />
    <meta name="twitter:creator" content="@cryptoquick" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 360: Pay to Quantum Resistant Hash</title>

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="/style.css" />

    <style>
        /* Dropdown menu styles for bip360.html */
        .group:hover .group-hover\:opacity-100 {
            opacity: 1 !important;
        }
        
        .group:hover .group-hover\:visible {
            visibility: visible !important;
        }
        
        .group:hover .group-hover\:rotate-180 {
            transform: rotate(180deg) !important;
        }
        
        .opacity-0 {
            opacity: 0;
        }
        
        .invisible {
            visibility: hidden;
        }
        
        .transition-all {
            transition-property: all;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
        
        .duration-200 {
            transition-duration: 200ms;
        }
        
        .z-50 {
            z-index: 50;
        }
        
        .w-48 {
            width: 12rem;
        }
        
        .mt-2 {
            margin-top: 0.5rem;
        }
        
        .left-0 {
            left: 0;
        }
        
        .absolute {
            position: absolute;
        }
        
        .relative {
            position: relative;
        }
        
        .rounded-md {
            border-radius: 0.375rem;
        }
        
        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        .border {
            border-width: 1px;
        }
        
        .px-4 {
            padding-left: 1rem;
            padding-right: 1rem;
        }
        
        .py-2 {
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        .block {
            display: block;
        }
        
        .hover\:bg-zinc-700:hover {
            background-color: rgb(63 63 70) !important;
        }
        
        .dark .hover\:bg-zinc-700:hover {
            background-color: rgb(63 63 70) !important;
        }
        
        /* Dropdown menu hover effects - use zinc-700 for both modes */
        html:not(.dark) .hover\:bg-zinc-700:hover {
            background-color: rgb(63 63 70) !important;
        }
        
        .dark .hover\:bg-zinc-700:hover {
            background-color: rgb(63 63 70) !important;
        }
        
        /* Ensure dropdown text turns orange on hover */
        .hover\:text-btc-orange:hover {
            color: #ff9900 !important;
        }
        
        html:not(.dark) .hover\:text-btc-orange:hover {
            color: #ff9900 !important;
        }
        
        .dark .hover\:text-btc-orange:hover {
            color: #ff9900 !important;
        }
        
        .ml-1 {
            margin-left: 0.25rem;
        }
        
        .w-4 {
            width: 1rem;
        }
        
        .h-4 {
            height: 1rem;
        }
        
        .flex {
            display: flex;
        }
        
        .items-center {
            align-items: center;
        }
        
        /* Dark mode specific dropdown styles */
        .dark .bg-white {
            background-color: rgb(39 39 42) !important;
        }
        
        .dark .border-gray-200 {
            border-color: rgb(55 65 81) !important;
        }
        
        .dark .text-gray-900 {
            color: rgb(243 244 246) !important;
        }
        
        .dark .text-gray-100 {
            color: rgb(243 244 246) !important;
        }
        
        /* Dark mode background and text colors */
        .dark\:bg-zinc-800 {
            background-color: rgb(39 39 42) !important;
        }
        
        .dark\:bg-zinc-900 {
            background-color: rgb(24 24 27) !important;
        }
        
        .dark\:text-gray-100 {
            color: rgb(243 244 246) !important;
        }
        
        .dark\:text-gray-300 {
            color: rgb(209 213 219) !important;
        }
        
        .dark\:border-gray-700 {
            border-color: rgb(55 65 81) !important;
        }
        
        /* Bitcoin orange color */
        .text-btc-orange {
            color: #ff9900 !important;
        }
        
        /* Navigation link styles */
        .nav-link {
            transition: color 0.2s ease;
        }
        
        .nav-link:hover {
            color: #ff9900 !important;
        }
        
        /* Current page navigation item (BIP 360) should be orange */
        .text-btc-orange {
            color: #ff9900 !important;
        }
        
        /* Ensure orange color works in both light and dark modes */
        html:not(.dark) .text-btc-orange {
            color: #ff9900 !important;
        }
        
        .dark .text-btc-orange {
            color: #ff9900 !important;
        }
        
        /* Ensure hover effects work for all nav items except the current page */
        .nav-link:hover:not(.text-btc-orange) {
            color: #ff9900 !important;
        }
        
        /* Keep the current page orange even on hover */
        .text-btc-orange:hover {
            color: #ff9900 !important;
        }
        
        /* Hover effects for both light and dark modes */
        html:not(.dark) .nav-link:hover {
            color: #ff9900 !important;
        }
        
        .dark .nav-link:hover {
            color: #ff9900 !important;
        }
        
        /* Dark mode toggle button visibility */
        .dark #toggleDark_light {
            display: block !important;
        }
        
        .dark #toggleDark_dark {
            display: none !important;
        }
        
        /* Light mode toggle button visibility (default state) */
        #toggleDark_light {
            display: none;
        }
        
        #toggleDark_dark {
            display: block;
        }
        
        /* Light mode styles */
        html:not(.dark) .bg-white {
            background-color: #ffffff !important;
        }
        
        html:not(.dark) .text-gray-900 {
            color: rgb(17 24 39) !important;
        }
        
        html:not(.dark) .text-gray-700 {
            color: rgb(55 65 81) !important;
        }
        
        html:not(.dark) .border-gray-200 {
            border-color: rgb(229 231 235) !important;
        }
        
        /* Ensure proper light mode colors for navigation */
        
        .dark .text-gray-900 {
            color: rgb(243 244 246) !important;
        }
        
        /* Light mode specific overrides */
        html:not(.dark) .bg-white {
            background-color: #ffffff !important;
        }
        
        html:not(.dark) .text-gray-900 {
            color: rgb(17 24 39) !important;
        }
        
        html:not(.dark) .text-gray-700 {
            color: rgb(55 65 81) !important;
        }
        
        html:not(.dark) .border-gray-200 {
            border-color: rgb(229 231 235) !important;
        }
        
        /* Specific styles for the main content area in light mode */
        html:not(.dark) h2 {
            color: rgb(17 24 39) !important;
        }
        
        html:not(.dark) .text-xl {
            color: rgb(17 24 39) !important;
        }
        
        html:not(.dark) a:not(.text-btc-orange) {
            color: rgb(17 24 39) !important;
        }
        
        /* Override the text-slate-700 for main content in light mode */
        html:not(.dark) .text-slate-700 {
            color: rgb(55 65 81) !important;
        }
        
        /* Ensure proper contrast for headings and important text */
        html:not(.dark) .font-semibold {
            color: rgb(17 24 39) !important;
        }
    </style>

    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function () { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // Simple dark mode implementation
        function toggleDarkMode(mode) {
            if (mode === 'dark') {
                document.documentElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                document.getElementById('toggleDark_light').style.display = 'block';
                document.getElementById('toggleDark_dark').style.display = 'none';
            } else {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                document.getElementById('toggleDark_light').style.display = 'none';
                document.getElementById('toggleDark_dark').style.display = 'block';
            }
        }

        // Initialize dark mode based on localStorage or system preference
        document.addEventListener('DOMContentLoaded', function () {
            const theme = localStorage.getItem('theme');
            if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                toggleDarkMode('dark');
            } else {
                toggleDarkMode('light');
            }
        });
        
        // Also initialize immediately for faster loading
        const theme = localStorage.getItem('theme');
        if (theme === 'dark' || (!theme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
</head>

<body class="bg-white dark:bg-zinc-900">
    <header class="bg-white dark:bg-zinc-800 border-gray-200 dark:border-gray-700 border-b border-b-gray-200 dark:border-b-gray-700">
        <nav class="flex items-center justify-center p-6 lg:px-8" aria-label="Global">
            <!-- <div class="flex lg:flex-1">&nbsp;</div> -->
            <div class="lg:flex lg:gap-x-12">
                <a href="index.html" class="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-btc-orange nav-link" style="text-decoration: none;">INTRO</a>
                <a href="bip360.html" class="text-sm/6 font-semibold text-btc-orange nav-link" style="text-decoration: none; color: #ff9900 !important;">BIP 360</a>
                <a href="https://github.com/cryptoquick/bips/blob/hourglass/bip-hourglass.mediawiki" target="_blank"
                    class="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-btc-orange nav-link" style="text-decoration: none;">HOURGLASS</a>
                <div class="relative group">
                    <span class="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-btc-orange nav-link flex items-center"
                        style="text-decoration: none; background: none; border: none; cursor: pointer;">
                        MEDIA
                        <svg class="w-4 h-4 ml-1 transition-transform group-hover:rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </span>
                    <div class="absolute left-0 mt-2 w-48 bg-white dark:bg-zinc-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
                        <a href="media.html" class="block px-4 py-2 text-sm text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-zinc-700 hover:text-btc-orange nav-link"
                            style="text-decoration: none;">COVERAGE</a>
                        <a href="assets/press.pdf" target="_blank" class="block px-4 py-2 text-sm text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-zinc-700 hover:text-btc-orange nav-link"
                            style="text-decoration: none;">PRESS</a>
                    </div>
                </div>
            </div>
            <!-- <div class="hidden lg:flex lg:flex-1 lg:justify-end">&nbsp;</div> -->
        </nav>
    </header>

    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-10 space-y-10 text-slate-700 dark:text-gray-300">
            <div class="flex flex-col space-y-4 pt-4 md:pt-8">
                <div class="flex justify-between">
                    <div class="flex">
                        <!-- Sun icon (show in dark mode, clicking switches to light) -->
                        <svg id="toggleDark_light" class="w-6 h-6 hover:cursor-pointer"
                            onclick="toggleDarkMode('light')" xmlns="http://www.w3.org/2000/svg" fill="none"
                            viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="display: none;">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                        </svg>
                        <!-- Moon icon (show in light mode, clicking switches to dark) -->
                        <svg id="toggleDark_dark" class="w-6 h-6 hover:cursor-pointer"
                            onclick="toggleDarkMode('dark')" xmlns="http://www.w3.org/2000/svg" fill="none"
                            viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                        </svg>
                    </div>
                </div>
                <div class="flex flex-col space-y-2">
                    <h2 data-pagefind-weight="10" class="text-2xl font-semibold">BIP 360: Pay to Quantum Resistant
                        Hash</h2>
                    <div class="flex justify-between">
                        <div class="text-xl font-semibold">2024-12-18</div>
                        <a href="https://github.com/cryptoquick/bips/blob/p2qrh/bip-0360.mediawiki"
                            target="_blank">View on GitHub</a>
                    </div>
                </div>

        <article class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
            <pre><code>  BIP: 360
  Title: Pay to Quantum Resistant Hash
  Layer: Consensus (soft fork)
  Author: Hunter Beast &lt;hunter@surmount.systems&gt;
          Ethan Heilman &lt;ethan.r.heilman@gmail.com&gt;
  Comments-Summary: No comments yet.
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0360
  Status: Draft
  Type: Standards Track
  Created: 2024-12-18
  License: BSD-3-Clause
</code></pre>
<h2> Introduction </h2>
<h3> Abstract </h3>
<p>This document proposes the introduction of a new output type, Pay to Quantum Resistant Hash (P2QRH), via a soft fork.
P2QRH provides the same tapscript functionality as Pay to TapRoot (P2TR) but removes the quantum-vulnerable
key-spend path in P2TR. By itself, P2QRH provides protection against long-exposure quantum attacks,
but requires PQ signatures to provide full security against Cryptanalytically-Relevant Quantum Computing (CRQCs).
P2QRH is designed to provide the foundation necessary for a future soft fork activating PQ signature verification
in tapscript.</p>
<h3> Copyright </h3>
<p>This document is licensed under the 3-clause BSD license.</p>
<h3> Motivation </h3>
<p>The primary threat to Bitcoin from Cryptanalytically-Relevant Quantum Computing (CRQCs)<ref name="CRQC">
A Cryptoanalytically-Relevant Quantum Computer is an <em>object</em> which is only loosely defined by <em>characteristics</em> in quantum physics as of today. It could be understood in the context of this BIP and in bitcoin that it's a <em>hardware-agnostic</em> computer supposed to have the architecture to keep <em>coherent</em> a sufficient number of logical qubits to be able to run the Shor algorithm in an efficient fashion.</ref>
is their potential to break the cryptographic assumptions of Elliptic Curve Cryptography (ECC), which secures Bitcoin's signatures and Taproot
commitments. Specifically, <a href="https://arxiv.org/pdf/quant-ph/0301141" target="_blank">Shor's algorithm</a> enables a CRQC to solve the
Discrete Logarithm Problem (DLP) exponentially faster than classical methods<ref name="shor">Shor's algorithm is
believed to need 10^8 operations to break a 256-bit elliptic curve public key.</ref>, allowing the derivation of
private keys from public keys-- a process referred to here as quantum key decryption.
<ref name="quantum-key-decryption">Meaning, deriving private keys from public keys via Shor's algorithm</ref>
Importantly, simply doubling the public
key length (e.g., using a hypothetical secp512k1 curve) would only make deriving the private key twice as hard,
offering insufficient protection. The computational complexity of this attack is further explored in
<a href="https://pubs.aip.org/avs/aqs/article/4/1/013801/2835275/The-impact-of-hardware-specifications-on-reaching" target="_blank"><em>The impact of hardware specifications on reaching quantum advantage in the fault-tolerant regime</em></a>.</p>
<p>This proposal aims to mitigate these risks by introducing a Pay to Quantum Resistant Hash (P2QRH) output type that
makes tapscript quantum resistant and enables the use of PQ signature algorithms. By adopting PQC, Bitcoin can enhance its quantum
resistance without requiring a hard fork or block size increase.</p>
<p>The vulnerability of existing Bitcoin addresses<ref name="address-vulnerability">A vulnerable Bitcoin address is any
<em>scriptPubKey</em> type that exposes an elliptic curve public key as <em>raw bytes</em> in a <em>block</em>, making it susceptible
to private key derivation through Shor's algorithm. This includes P2PK outputs and any script that contains an
unprotected public key.</ref> is detailed in
<a href="https://web.archive.org/web/20240715101040/https://www2.deloitte.com/nl/nl/pages/innovatie/artikelen/quantum-computers-and-the-bitcoin-blockchain.html" target="_blank">this Deloitte report</a>.
The report estimates that in 2020 approximately 25% of the Bitcoin supply is held within addresses vulnerable to
quantum attack. As of the time of writing, that number is now closer to 20%. Independently, Bitcoin developer Pieter
Wuille <a href="https://web.archive.org/web/20220531184542/https://twitter.com/pwuille/status/1108085284862713856" target="_blank">reasons</a> even more addresses might be vulnerable, representing
5M to 10M bitcoin.</p>
<p>Ordinarily, when a transaction is signed, the public key is explicitly stated in the input script. This means that the
public key is exposed on the blockchain when the transaction is spent, making it vulnerable to quantum attack until
it's mined. One way to mitigate this is to submit the transaction directly to a mining pool, bypassing the mempool.
This process is known as an out-of-band transaction or a private mempool. In this case, the mining pool must be trusted
not to reveal the transaction public key to attackers. The problem with this approach is that it requires a trusted
third party, which the P2QRH proposal aims to avoid. It also doesn't account for block reorg attacks, which would
reveal public keys in blocks that were once mined but are now orphaned and must be mined again. Additionally,
it depends on the mining pool whether they reveal their block template to either the public or to miners.</p>
<p>Not having public keys exposed on-chain is an important step for quantum security. Otherwise, funds would need to be
spent to new addresses on a regular basis in order to prevent the possibility of a "long-exposure CRQC attack" recovering
the key behind high-value addresses. A long-exposure quantum attack can be considered one performed with chain data, such
as that from a used address or one encoded in a spend script. This is likely to be more common early on, as early
quantum computers must be run for longer in order to overcome errors caused by noise. A "short-exposure quantum attack"
would be one performed on keys in the mempool, which is seen as much more difficult given the block time, and so it
requires more sophisticated CRQCs.<ref name="short-exposure">
In the paper
<a href="https://arxiv.org/pdf/2306.08585" target="_blank">How to compute a 256-bit elliptic curve private key with only 50 million Toffoli gates</a>
the authors estimate that a CRQC with 28 million superconducting physical qubits would take 8.3 seconds to calculate a
256-bit key, while a CRQC with 6.9 million physical qubits would take 58 seconds. This implies that a CRQC with 4x as
many qubits would be roughly 7 times faster.
</ref></p>
<p>As the value being sent increases, so too should the fee in order to commit the transaction to the chain as soon as
possible. Once the transaction is mined, it makes useless the public key revealed by spending a UTXO, so long as it is
never reused.</p>
<p>As the first step to address these issues we propose Pay to Quantum Resistant Hash (P2QRH), an output type that allows
tapscript to be used in a quantum resistant manner.
This new output type protects transactions submitted to the mempool and helps preserve the fee market by
preventing the need for private, out-of-band mempool transactions.</p>
<p>The following table is intended to inform the average Bitcoin user whether their bitcoin is vulnerable to a long-exposure
quantum attack:</p>
<table><thead><tr><th>+ Output types vulnerable to long-exposure attacks on unspent addresses</th></tr></thead><tbody>
<tr><td>Type</td></tr>
<tr><td>P2PK</td></tr>
<tr><td>P2PKH</td></tr>
<tr><td>P2MS</td></tr>
<tr><td>P2SH</td></tr>
<tr><td>P2WPKH</td></tr>
<tr><td>P2WSH</td></tr>
<tr><td>P2TR</td></tr>
<tr><td>P2QRH</td></tr>
</tbody></table>
<p>¹ Funds in P2PKH, P2SH, P2WPKH, and P2WSH outputs become vulnerable to long-exposure quantum attacks when their input script is revealed. An address is no longer safe against long-exposure quantum attacks after funds from it have been spent.</p>
<p>It should be noted that Taproot outputs are vulnerable in that they encode a 32-byte x-only public key, from which a
full public key can be reconstructed.</p>
<p>If a CRQC recovers an extended public key (xpub), including its chain code, it can derive all non-hardened child public
keys by guessing or iterating through child indexes, as allowed by BIP-32's non-hardened derivation. With Shor's
algorithm, the CRQC could then compute the corresponding non-hardened child private keys directly from those public keys,
without needing the extended private key (xprv) or an exposed child private key. Hardened child keys remain secure since
they cannot be derived from the xpub alone. However, if the xprv is exposed, then all child private keys--both hardened
and non-hardened--become vulnerable. Thus, in a quantum context, the xpub alone is sufficient to expose all non-hardened
child private keys.</p>
<h4> Long Exposure and Short Exposure Quantum Attacks </h4>
<p>A Long Exposure Quantum Attack is an attack in which the public key has been exposed on the blockchain for an extended
period of time, giving an attacker ample opportunity to break the cryptography. This affects:</p>
<ul>
<li>P2PK outputs (Satoshi's coins, CPU miners, starts with 04)</li>
<li>Reused addresses (any type, except P2QRH)</li>
<li>Taproot addresses (starts with bc1p)</li>
<li>Extended public keys, commonly known as "xpubs"</li>
<li>Wallet descriptors</li>
</ul>
<p>A Short Exposure Quantum Attack is an attack that must be executed quickly while a transaction is still in the mempool,
before it is mined into a block. This affects:</p>
<ul>
<li>Any transaction in the mempool (except for P2QRH)</li>
</ul>
<p>Short-exposure attacks require much larger, more expensive CRQCs since they must be executed within the short window
before a transaction is mined. Long-exposure attacks can be executed over a longer timeframe since the public key remains
exposed on the blockchain indefinitely.</p>
<p>Coinbase outputs to P2PK keys go as far as block 200,000, so there are, at the time of writing, 1,723,848 coins that
are vulnerable from the first epoch in P2PK outputs alone. The majority of these have a block reward of 50 coins each,
and there are roughly 34,000 distinct P2PK scripts that are vulnerable. These coins can be considered
"Satoshi's Shield." Any addresses with a balance of less than the original block subsidy of 50 coins can be considered
cryptoeconomically incentive incompatible to capture until all of these are mined, and these addresses serve to provide
time to transition Bitcoin to implement post-quantum security.</p>
<p>It's for the above reason that, for those who wish to be prepared for quantum emergency, it is recommended that no more
than 50 bitcoin are kept under a single, distinct, unused Native SegWit (P2WPKH, "bc1q") address at a time. This is
assuming that the attacker is financially motivated instead of, for example, a nation state looking to break confidence
in Bitcoin. Independently, this assumes that other vulnerable targets such as central banks have upgraded their
cryptography by this time.</p>
<p>The Commercial National Security Algorithm Suite (CNSA) 2.0 has a timeline for software and networking equipment to be
upgraded by 2030, with browsers and operating systems fully upgraded by 2033. According to NIST IR 8547, Elliptic Curve
Cryptography is planned to be disallowed within the US federal government after 2035. An exception is made for hybrid
cryptography, which is the use of ECC and post-quantum algorithms together.</p>
<p>Although the main threat posed by CRQCs is to the signatures used in Bitcoin, a smaller threat is to Bitcoin's hash
algorithms. In particular, while a CRQC could use <a href="https://en.wikipedia.org/wiki/Grover's_algorithm" target="_blank">Grover's algorithm</a>
to gain a quadratic speedup on brute-force attacks on the hash functions used in Bitcoin, a significantly more powerful
CRQC is needed for these attacks to meaningfully impact Bitcoin. For instance, a preimage attack on
HASH160 <ref name="hash160">Used by P2PKH, P2SH, and P2WPKH addresses, though not P2WSH because it uses 256-bit hashes.</ref>
using Grover's algorithm would require at least 10^24 quantum operations. As for Grover's application to mining, see
<a href="https://quantumcomputing.stackexchange.com/a/12847" target="_blank">Sam Jaques' post on this</a>.</p>
<h3> Design </h3>
<p>This is the first in a series of BIPs under a QuBit soft fork. A qubit is a fundamental unit of quantum computing, and
the capital B refers to Bitcoin. The name QuBit also rhymes to some extent with SegWit. This BIP proposes a new output type
called P2QRH (Pay to Quantum Resistant Hash). This output type is designed to support post-quantum signature algorithms
but those algorithms will be specified in future BIPs.</p>
<p>It is proposed to use SegWit version 3. This results in addresses that start with bc1r, which could be a useful way to
remember that these are quantum (r)esistant addresses. This is referencing the lookup table under
<a href="/173" target="_blank">BIP-173</a>.</p>
<p>P2QRH (Pay to Quantum Resistant Hash) is a new output type that commits to the root of a tapleaf merkle tree. It is functionally
the same as a P2TR (Pay to Taproot) output with the quantum vulnerable key-spend path removed. Since P2QRH has no key-spend path, P2QRH omits the
taproot internal key as it is not needed. Instead a P2QRH output is just the 32 byte root of the tapleaf merkle tree as defined
in <a href="/341" target="_blank">BIP-341</a> and hashed with the tag "QuantumRoot" as shown below.</p>
<img src="merkletree.png" />
<p>To construct a P2QRH output we follow the same process as <a href="/341" target="_blank">BIP-341</a>
to compute the tapscript merkle root. However, instead of the root of the Merkle tree being hashed together with the internal
key in P2QRH the root is hashed by itself using the tag "QuantumRoot".</p>
<pre><code>D = tagged_hash(&quot;TapLeaf&quot;, bytes([leaf_version]) + ser_script(script))
CD = tagged_hash(&quot;TapBranch&quot;, C + D)
CDE = tagged_hash(&quot;TapBranch&quot;, E + CD)
ABCDE = tagged_hash(&quot;TapBranch&quot;, AB + CDE)
Root = tagged_hash(&quot;QuantumRoot&quot;, ABCDE)
</code></pre>
<p>A P2QRH input witness provides the following:</p>
<pre><code>initial stack element 0,
...,
initial stack element N,
tapleaf script,
control block = [control byte, 32 * m byte Merkle path] # m is the depth of the Merkle tree
</code></pre>
<p>The initial stack elements provide the same functionality as they do in P2TR. That is, they place elements on the stack to
be evaluated by the tapleaf script, a.k.a. the redeem script.</p>
<p>The control block is a 1 + 32 * m byte array, where the first byte is the control byte and the next 32*m bytes are the
Merkle path to the tapleaf script. The control byte is the same as the control byte in a P2TR control block,
including the 7 bits are used to specify the tapleaf version. The parity bit of the control byte is always 1
since P2QRH does not have a key-spend path. We omit the public key from the control block as it is not needed in P2QRH.
We maintain support for the optional annex in the witness (see specification for more details).</p>
<h3> Rationale </h3>
<p>Our design to augment Bitcoin with quantum resistance is guided by the following principles:</p>
<p><strong>Minimize changes.</strong> We should reuse existing Bitcoin code and preserve
existing software behavior, workflows, user expectations and compatibility whenever possible.</p>
<p><strong>Gradual upgrade path.</strong> We should provide an upgrade path for wallets and exchanges which can be
carried out gradually and iteratively rather than all at once. This is critical as the earlier the ecosystem
begins upgrading to quantum resistance, the lower the number of coins at risk when quantum attacks become practical.</p>
<p><strong>Use standardized post-quantum signature algorithms.</strong>  Standardized algorithms have undergone the most scrutiny and
are likely to be most well supported and well studied going forward. The entire Bitcoin ecosystem will benefit
from using the most popular post-quantum signature algorithms, including leveraging hardware acceleration
instructions, commodity trusted hardware, software libraries and cryptography research.</p>
<p><strong>Provide security against unexpected cryptanalytic breakthroughs.</strong> Consider the risk
if Bitcoin only supported one PQ signature algorithm, and then following the widespread rollout of CRQCs, a critical
weakness is unexpectedly discovered in this signature algorithm. There would be no safe algorithm available. We believe that
prudence dictates we take such risks seriously and ensure that Bitcoin always has at least two secure signature algorithms built
on orthogonal cryptographic assumptions. In the event one algorithm is broken, an alternative will be available. An added benefit
is that parties seeking to securely store bitcoins over decades can secure their coins under multiple algorithms,
ensuring their coins will not be stolen even in the face of a catastrophic break in one of those signature algorithms.</p>
<p>Based on these principles, we propose two independent changes that together provide Bitcoin with
full quantum resistance. In this BIP, we introduce a new output type called P2QRH (Pay to Quantum Resistant Hash) so that tapscript
can be used in a quantum resistant manner. In a future BIP, we enable tapscript programs to verify two Post-Quantum (PQ) signature
algorithms, ML-DSA (CRYSTALS-Dilithium) and SLH-DSA (SPHINCS+). It is important to consider these two changes together because P2QRH must
be designed to support the addition of these PQ signature algorithms. The full description of these signatures will be provided in a future BIP.</p>
<h4> P2QRH </h4>
<p>P2QRH is simply P2TR with the quantum vulnerable key-spend path removed so that it commits to the root of
the tapleaf merkle tree in the output. This allows P2QRH to reuse the mature and battle tested P2TR, tapleaf
and tapscript code already in Bitcoin. This reduces the implementation burden on wallets, exchanges, and
libraries since they can reuse code they already have.</p>
<p>Both P2WSH (Pay 2 Witness Script Hash) and P2QRH protect against long-exposure quantum attacks and both provide
the same 256-bit security level. One may ask why not use the existing output type P2WSH instead of add a new one?
The problem with P2WSH is that it only works with pre-tapscript Script and cannot work with tapscript Script.
New protocols and programs in the Bitcoin ecosystem have largely moved to tapscript. Using P2WSH would require turning
back the clock and forcing projects to move from tapscript to pre-tapscript. More importantly, tapscript provides a far
easier and safer upgrade path for adding PQ signatures. Changes to pre-tapscript to enable it to support PQ signatures would likely
require adding tapscript features into pre-tapscript. Even if this was possible, it would represent far more work and
risk than adding a new output type like P2QRH. Tapscript, and thereby a tapscript compatible output such as P2QRH,
is the most plausible and convenient upgrade path to full quantum resistance.</p>
<h4> PQ signatures </h4>
<p>By separating P2QRH from the introduction of PQ signatures, relying parties can move from P2TR to P2QRH
without simultaneously having to change from Schnorr signatures to PQ signatures. Simply moving coins from
P2TR to P2QRH protects those coins from long-exposure quantum attacks. Then to gain full quantum resistance,
verification of PQ signatures can be added as an additional tapleaf alongside Schnorr signatures<ref name="mattleaf">Matt Corallo, <a href="https://groups.google.com/g/bitcoindev/c/8O857bRSVV8/m/rTrpeFjWDAAJ" target="_blank">Trivial QC signatures with clean upgrade path</a>, (2024)</ref>.
When quantum attacks become practical, users would then be fully protected as the P2QRH output would allow
them to switch to sending their coins using the PQ signature algorithms. This allows the upgrade to quantum
resistance to be largely invisible to users.</p>
<p>Consider the P2QRH output with three tapscripts:</p>
<ul>
<li>Spend requires a Schnorr signature</li>
<li>Spend requires a ML-DSA signature</li>
<li>Spend requires a SLH-DSA signature</li>
</ul>
<p>In the event that Schnorr signatures are broken, users can spend their coins using ML-DSA.
If both Schnorr and ML-DSA are broken, the user can still rely on SLH-DSA.
While this pattern allows users to spend their coins securely without revealing the public
keys associated with vulnerable algorithms, the user can compromise their own security if
they leak these public keys in other contexts, e.g. key reuse.</p>
<p>One intent in supporting Schnorr, ML-DSA, and SLH-DSA in tapscript, is to allow parties to construct outputs such that funds
are still secure even if two of the three the signature algorithms are completely broken. This is motivated by the use case
of securely storing Bitcoins in a cold wallet for very long periods of time (50 to 100 years).</p>
<p>For PQ signatures we considered the NIST approved SLH-DSA (SPHINCS+), ML-DSA (CRYSTALS-Dilithium),
FN-DSA (FALCON). Of these three algorithms, SLH-DSA has the largest signature size, but is the most conservative
choice from a security perspective because SLH-DSA is based on well studied and time-tested hash-based cryptography.
Both FN-DSA and ML-DSA signatures are significantly smaller than SLH-DSA signatures but are based on newer lattice-based
cryptography. Since ML-DSA and FN-DSA are both similar lattice-based designs, we choose to only support one of them as the
additional value in diversity of cryptographic assumptions would be marginal. It should be noted that ML-DSA and FN-DSA do
rely on different lattice assumptions and it may be that case that a break in one algorithm's assumptions would not necessarily
break the assumptions used by the other other algorithm.</p>
<p>We also considered SQIsign. While it outperforms the three other PQ signature algorithms by having the smallest signatures,
it has the worst verification performance and requires a much more complex implementation. We may revisit SQIsign separately in the
future as recent research shows massive performance improvements to SQIsign in version 2.0.<ref name="sqisign2"> "[SQIsign] signing is now nearly 20× faster, at 103.0 Mcycles, and verification is more than 6× faster, at 5.1 Mcycles" <a href="https://csrc.nist.gov/csrc/media/Projects/pqc-dig-sig/documents/round-2/spec-files/sqisign-spec-round2-web.pdf" target="_blank">SQIsign: Algorithm specifications and supporting documentation Version 2.0 (February 5 2025)</a></ref>.</p>
<p>ML-DSA is intended as the main PQ signature algorithm in Bitcoin. It provides a good balance of security, performance
and signature size and is likely to be the most widely supported PQ signature algorithm on the internet. SLH-DSA has a radically
different design and set of cryptographic assumptions than ML-DSA. As such SLH-DSA provides an effective
hedge against an unexpected cryptanalytic breakthrough.</p>
<p>P2QRH, ML-DSA, and SLH-DSA could be activated simultaneously in a single soft fork or P2QRH could be activated first and then
ML-DSA and SLH-DSA could be independently activated. If at some future point another signature
algorithm was desired it could follow this pattern.</p>
<p>We consider two different paths for activating PQ signatures in Bitcoin. The first approach is to redefine OP_SUCCESSx opcodes for each
signature algorithm. For ML-DSA this would give us OP_CHECKMLSIG, OP_CHECKMLSIGVERIFY and OP_CHECKMLSIGADD. The second approach is to use a new tapleaf version that changes the OP_CHECKSIG opcodes to support the
new PQ signature algorithms. In both cases, we would need to include as part of the soft fork an increase in the tapscript stack element
size to accommodate the larger signatures and public keys sizes of the PQ signature algorithms.</p>
<p>The OP_SUCCESSx approach has the advantage of providing a straightforward path to add new signature algorithms in the future. Simply redefine
a set of five OP_SUCCESSx opcodes for the new signature algorithm. This would allow us to activate a single PQ signature at a time, adding
new ones as needed. Additionally this approach allows developers to be very explicit in the signature algorithm type that they wish to verify.
The main disadvantage is that it uses five OP_SUCCESSx opcodes per signature algorithm. Supporting ML-DSA and SLH-DSA would require ten new opcodes.</p>
<p>Adding PQ signatures via a tapleaf version increase does not introduce any new opcodes and allows previously written tapscript programs to be used with PQ signatures
by simply using the new tapleaf version. Instead of developers explicitly specifying the intended signature algorithm through an opcode, the algorithm
to use must be indicated within the public key or public key hash<sup id="cite_ref_1"><a href="#cite_ref_1">1</a></sup>.
The disadvantage of this approach is that it requires a new tapleaf version each time we want to add a new signature algorithm.</p>
<p>Both approaches must raise the stack element size limit. In the OP_SUCCESSx case, the increased size limit would only be effect for transaction outputs
that use of the new opcodes. Otherwise this stack element size limit increase would be a soft fork. If the tapleaf version is used, then the stack
element size limit increase would apply to any tapscript program with the new tapleaf version.</p>
<p>To improve the viability of the activation client and adoption by wallets and libraries, a library akin to
libsecp256k1 will be developed. This library, <a href="https://github.com/cryptoquick/libbitcoinpqc" target="_blank">libbitcoinpqc</a>, will support the new PQ signature algorithms
and can be used as a reference for other language-native implementations.</p>
<h4> PQ signature size </h4>
<p>Post-quantum public keys are generally larger than those used by ECC, depending on the security level. Originally BIP-360
proposed NIST Level V, 256-bit security, but this was changed to NIST Level I, 128-bit security due to concerns over the
size of the public keys, the time it would take to verify signatures, and being generally deemed "overkill".</p>
<p>We recognize that the size of ML-DSA (CRYSTALS-Dilithium) and SLH-DSA (SPHINCS+) signatures + public key pairs is a significant concern.
By way of comparison with Schnorr public key + signature pairs, SLH-DSA is roughly 80x larger and ML-DSA is roughly 40x larger. This means to
maintain present transaction throughput, an increase in the witness discount may be desired.</p>
<p>An increase in the witness discount must not be taken lightly. Parties may take advantage of this discount for purposes other than
authorizing transactions (e.g., storage of arbitrary data as seen with "inscriptions"). An increase in the witness discount would
not only impact node runners but those with inscriptions would have the scarcity of their non-monetary assets affected.</p>
<p>There was some hope of designing P2QRH such that discounted public keys and signatures could not be repurposed for the storage of
arbitrary data by requiring that they successfully be verified before being written to Bitcoin's blockchain, a.k.a. "JPEG resistance".
Later research <sup id="cite_ref_2"><a href="#cite_ref_2">2</a></sup>
provided strong evidence that this was not a feasible approach for the NIST approved Post-Quantum signature algorithms.
It is an open question if Post-Quantum signature algorithms can be designed to provide JPEG resistance.</p>
<h4> Raising tapscript's stack element size </h4>
<p>A problem faced by any attempt to add PQ signatures to tapscript is that the stack elements in tapscript cannot be larger than 520 bytes
because the MAX_SCRIPT_ELEMENT_SIZE=520. This is problematic because PQ signature algorithms often have signatures and
public keys in excess of 520 bytes. For instance:</p>
<ul>
<li>ML-DSA public keys are 1,312 bytes and signatures are 2,420 bytes</li>
<li>SLH-DSA public keys are 32 bytes and signatures are 7,856 bytes</li>
</ul>
<p>We will first look at our approach to the problem of PQ signatures and then give our solution for public keys larger than 520 bytes.</p>
<p>To keep P2QRH small and simple, we have opted not to raise the stack element size limit as part of P2QRH, but instead make this change when
adding of PQ signatures. That said, we are not strongly opposed to putting this increase in P2QRH.</p>
<p>We propose a stack element size limit of 8,000 bytes. We arrive at 8,000 by rounding up from the needed 7,856 bytes.</p>
<p>OP_DUP will duplicate any stack element. Thus, if we allowed OP_DUP to duplicate stack elements of size 8,000 bytes, it would be possible
to write a tapscript which will duplicate stack elements until it reaches the maximum number of elements on stack, i.e. 1000 elements.
An increase from 520 bytes to 8,000 bytes would increase the memory footprint from 520 KB to 8 MB.</p>
<p>To prevent OP_DUP from creating an 8 MB stack by duplicating stack elements larger than 520 bytes we define OP_DUP to fail on stack
elements larger than 520 bytes. Note this change to OP_DUP is not consensus critical and does not require any sort of fork. This is
because currently there is no way to get a stack element larger than 520 bytes onto the stack so triggering this rule is currently
impossible and would only matter if the stack element size limit was raised.</p>
<h4> Public keys larger than 520 bytes </h4>
<p>Turning our attention to public keys larger than 520 bytes. This is not needed for SLH-DSA as its public key is only 32 bytes.
This is a different problem than signatures as public keys are typically pushed onto
the stack by the tapleaf script (redeem script) to commit to public keys in output. The OP_PUSHDATA opcode in tapscript fails if asked to push
more than 520 bytes onto the stack.</p>
<p>To solve this issue, for signature schemes with public keys greater than 520 bytes, we use the hash of the public key in the tapleaf script.
We then package the public key and signature together as the same stack element on the input stack. Since the hash of the public key is
only 32 bytes, the tapleaf script can push it on the stack as it does today. Consider the following example with a
OP_CHECKMLSIG opcode for ML-DSA:</p>
<pre><code>stack = [pubkey||signature]
tapscript = [OP_PUSHDATA HASH256(expected_pubkey), OP_CHECKMLSIG]
</code></pre>
<ol>
<li>OP_PUSHDATA HASH256(expected_pubkey) updates the stack to <a href="HASH256(expected_pubkey)," target="_blank">pubkey||signature</a></li>
<li>OP_CHECKMLSIG pops HASH256(expected_pubkey) and pubkey||signature, checks HASH256(expected_pubkey) == pubkey and verifies signature against pubkey.</li>
</ol>
<h4> Future considerations </h4>
<p>Additional follow-on BIPs will be needed to implement PQ signature algorithms, signature aggregation, and full BIP-32 compatibility
(if possible) <ref name="bip-32">BIP-32 relies on elliptic curve operations to derive keys from xpubs to support
watch-only wallets, which PQC schemes may not support.</ref>. However, until specialized quantum cryptography hardware
is widespread and signature aggregation schemes are thoroughly vetted, P2QRH addresses are an intermediate solution
to quantum threats.</p>
<h2> Specification </h2>
<p>We define the Pay to Quantum Resistant Hash (P2QRH) output structure as follows.</p>
<h3> Pay to Quantum Resistant Hash (P2QRH) </h3>
<p>A P2QRH output is simply the root of the tapleaf Merkle tree defined in <a href="/341" target="_blank">BIP-341</a>
and used as an internal value in P2TR.</p>
<p>To construct a P2QRH output we follow the same process as <a href="/341" target="_blank">BIP-341</a>
to compute the tapscript merkle root. However, instead of the root of the Merkle tree being hashed together with the internal
key in P2QRH the root is hashed by itself using the tag "QuantumRoot" and then set as the witness program.</p>
<h3> Address Format </h3>
<p>P2QRH uses SegWit version 3 outputs, resulting in addresses that start with <code>bc1r</code>, following
<a href="/173" target="_blank">BIP-173</a>. Bech32 encoding maps version 3 to the
prefix <code>r</code>.</p>
<p>Example P2QRH address:</p>
<p><code>bc1r...</code> (32-byte Bech32m-encoded tapleaf merkle root)</p>
<h3> ScriptPubKey </h3>
<p>The <code>scriptPubKey</code> for a P2QRH output is:</p>
<pre><code>  OP_PUSHNUM_3 OP_PUSHBYTES_32 &lt;nowiki&gt;&lt;hash&gt;&lt;&#x2F;nowiki&gt;
</code></pre>
<p>Where:</p>
<ul>
<li><code>OP_PUSHNUM_3</code> (<code>0x53</code>) indicates SegWit version 3.</li>
<li><nowiki><hash></nowiki> is the 32-byte tapleaf merkle root.</li>
</ul>
<h4> Script Validation </h4>
<p>A P2QRH output is a native SegWit output (see <a href="/141" target="_blank">BIP141</a>) with version number 3, and a 32-byte witness program.
Unlike taproot this witness program is the tapleaf merkle root. For the sake of comparison we have, as much as possible, copied the
language verbatim from the <a href="/341" target="_blank">BIP341</a> script validation section.</p>
<ul>
<li>Let <em>q</em> be the 32-byte array containing the witness program (the second push in the scriptPubKey) which represents root of tapleaf merkle tree.</li>
<li>Fail if the witness stack does not have two or more elements.</li>
<li>If there are at least three witness elements, and the first byte of the last element is 0x50, this last element is called <em>annex</em> <em>a</em> and is removed from the witness stack. The annex (or the lack of thereof) is always covered by the signature and contributes to transaction weight, but is otherwise ignored during taproot validation.</li>
<li>There must be at least two witness elements left.
<ul>
<li>Call the second-to-last stack element <em>s</em>, the script (as defined in <a href="/341" target="_blank">BIP341</a>)</li>
<li>The last stack element is called the control block <em>c</em>, and must have length <em>1 + 32 * m</em>, for a value of <em>m</em> that is an integer between 0 and 128, inclusive. Fail if it does not have such a length.</li>
<li>Let <em>v = c[0] &amp; 0xfe</em> be the <em>leaf version</em> (as defined in <a href="/341" target="_blank">BIP-341</a>). To maintain <em>leaf version</em> encoding compatibility the last bit of c[0] is unused and must be 1 <sup id="cite_ref_3"><a href="#cite_ref_3">3</a></sup>.</li>
<li>Let <em>k<sub>0</sub> = hash<sub>TapLeaf</sub>(v || compact_size(size of s) || s)</em>; also call it the <em>tapleaf hash</em>.</li>
<li>For <em>j</em> in <em>[0,1,...,m-1]</em>:
<ul>
<li>Let <em>e<sub>j</sub> = c[33+32j:65+32j]</em>.</li>
<li>Let _k<sub>j+1</sub> depend on whether <em>k<sub>j</sub> &lt; e<sub>j</sub></em> (lexicographically):
*  If <em>k<sub>j</sub> &lt; e<sub>j</sub></em>: <em>k<sub>j+1</sub> = hash<sub>TapBranch</sub>(k<sub>j</sub> || e<sub>j</sub>)</em>.
*  If <em>k<sub>j</sub> ≥ e<sub>j</sub></em>: <em>k<sub>j+1</sub> = hash<sub>TapBranch</sub>(e<sub>j</sub> || k<sub>j</sub>)</em>.</li>
</ul>
</li>
<li>Let <em>r = hash<sub>QuantumRoot</sub>(k<sub>m</sub>)</em>.</li>
<li>If <em>q ≠ r</em>, fail.</li>
<li>Execute the script, according to the applicable script rules, using the witness stack elements excluding the script <em>s</em>, the control block <em>c</em>, and the annex <em>a</em> if present, as initial stack. This implies that for the future leaf versions (non-<em>0xC0</em>) the execution must succeed.</li>
</ul>
</li>
</ul>
<p>The steps above follow the script path spending logic from <a href="/341" target="_blank">BIP-341</a> with the following changes:</p>
<ul>
<li>The witness program is the tapleaf merkle root and not a public key. This means that we skip directly to BIP-341 spend path tapleaf merkle tree validation.</li>
<li>We compute the tagged tapleaf merkle root r and compare it directly to the witness program q.</li>
<li>The control block is 1 + 32<em>m bytes, instead of 33 + 32</em>m bytes.</li>
</ul>
<h4> Sighash Calculation </h4>
<p>The sighash for P2QRH outputs follows the same procedure as defined in <a href="/341" target="_blank">BIP-341</a> for Taproot transactions:</p>
<ul>
<li><strong>Signature Message:</strong> A single-SHA256 of a tagged hash with the tag "TapSighash", containing transaction data.</li>
<li><strong>Tagged Hash:</strong> Computed as H(tag || tag || data) where H is SHA256 and tag is the SHA256 of the tag name.</li>
<li><strong>Key Data:</strong> In addition to transaction data, the sighash includes the spent output's scriptPubKey.</li>
<li><strong>Extension Fields:</strong> Specific data is included or excluded from the sighash based on the sighash flag.</li>
</ul>
<p>This signature hash construction ensures transaction malleability is prevented while providing flexibility through
different sighash types (DEFAULT, ALL, NONE, SINGLE, and ANYONECANPAY variants). The exact computation follows the
procedure specified in BIP-341 to maintain compatibility with Taproot signatures.</p>
<p>If a sighash flag other than DEFAULT is needed, it can be placed in the transaction witness. In this case, it will be
the only field in the witness.</p>
<h3> Compatibility with BIP-141 </h3>
<p>By adhering to the SegWit transaction structure and versioning, P2QRH outputs are compatible with existing transaction
processing rules. Nodes that do not recognize SegWit version 3 will treat these outputs as anyone-can-spend but, per
<a href="/141" target="_blank">BIP-141</a>, will not relay or mine such transactions.</p>
<h3> Transaction Size and Fees </h3>
<p>Equivalent P2QRH and P2TR outputs are always the same size. P2QRH inputs can be slightly larger or smaller than
their equivalent P2TR inputs. Let's consider the cases:</p>
<p><strong>P2TR key-spend</strong> P2QRH inputs will be larger than P2TR inputs when the P2TR output would have been spent via the key-spend path.
P2QRH quantum resistance comes from removing the P2TR key-spend path. Consequently it cannot make use of taproot's optimization
where P2TR key-spends do not require including a merkle path in the P2TR input. If the Merkle tree only has a single tapleaf,
no Merkle path is needed in the control block giving us a 1 byte control block.</p>
<p>P2QRH witness (103 bytes):</p>
<pre><code>[count] (1 byte), # Number of elements in the witness
[size] signature  (1 + 64 bytes = 65 bytes),
tapleaf script = [size] [OP_PUSHBYTES_32, 32 byte public key, OP_CHECKSIG] (1 + 1 + 32 + 1 bytes = 35 bytes),
control block = [size] [control byte]  (1 + 1 = 2 bytes)
</code></pre>
<p>P2TR key-spend witness (66 bytes):</p>
<pre><code>[count] (1 byte), # Number of elements in the witness
[size] signature (1 + 64 bytes = 65 bytes)
</code></pre>
<p>Thus, the P2QRH input would be 103 - 66 = 37 bytes larger than a P2TR key-spend input.</p>
<p>If the Merkle tree has more than a single tapleaf, then the Merkle path must be included in
the control block.
P2QRH witness (103+32*m bytes)</p>
<pre><code>[count] (1 byte), # Number of elements in the witness
[size] signature  (64 + 1 bytes = 65 bytes),
tapleaf script = [size] [OP_PUSHBYTES_32, 32 byte public key, OP_CHECKSIG] (34 + 1 bytes = 35 bytes),
control block = [size] [control byte, 32 * m byte Merkle path]  (1 + 1 + 32 * m = 2 + 32 * m bytes)
</code></pre>
<p>For a Merkle path of length m, it would add an additional ~32 * m bytes to the P2QRH input. This would
make it 37 + 32 * m bytes larger than a P2TR key-spend input<sup id="cite_ref_4"><a href="#cite_ref_4">4</a></sup>.</p>
<p>Considering a P2QRH output that has a PQ signature tapleaf and a Schnorr tapleaf. The P2QRH witness to spend the Schnorr path
would be 103 + 32 * 1 = 135 bytes. It is unfortunate that we can not use the key-spend optimization for P2QRH inputs, but the key-spend optimization is
exactly what makes P2TR vulnerable to quantum attacks. If spend-key was quantum resistant we wouldn't need P2QRH at all.</p>
<p><strong>P2TR script-spend</strong> P2QRH inputs will be smaller than equivalent script-spend path P2TR inputs. This is because P2QRH inputs
do not require that the input includes a public key in the witness control block to open the commitment to the tapleaf merkle root.
An equivalent P2QRH input will be 32 bytes smaller than a P2TR script-spend input.</p>
<h3> Performance Impact </h3>
<p>P2QRH is slightly more computationally performant than P2TR, as the operations to spending a P2QRH output is a strict
subset of the operations needed to spend a P2TR output.</p>
<h3> Backward Compatibility </h3>
<p>Older wallets and nodes that have not been made compatible with SegWit version 3 and P2QRH will not recognize these
outputs. Users should ensure they are using updated wallets and nodes to use P2QRH addresses and validate transactions
using P2QRH outputs.</p>
<p>P2QRH is fully compatible with tapscript and existing tapscript programs can be used in P2QRH outputs without modification.</p>
<h2> Security </h2>
<p>P2QRH outputs provide the same tapscript functionality as P2TR outputs, but without the quantum-vulnerable key-spend
path. This enables users, exchanges and other hodlers to easily move their coins from taproot outputs to P2QRH outputs
and thereby protect their coins from long-exposure quantum attacks. The protection from long-exposure quantum attacks
does not depend on the activation of post-quantum signatures in Bitcoin but does require that users do not expose their
quantum vulnerable public keys to attackers via address reuse or other unsafe practices.</p>
<p>P2QRH uses a 256-bit hash output, providing 128 bits of collision resistance and 256 bits of preimage resistance.
This is the same level of security as P2WSH, which also uses a 256-bit hash output.</p>
<p>P2QRH does not, by itself, protect against short-exposure quantum attacks, but such attacks can be mitigated by the future
activation of post-quantum signatures in Bitcoin. With P2QRH hash, these would provide full quantum resistance to P2QRH outputs in Bitcoin.
That said, the protection offered by resistance to long-exposure quantum attacks should not be underestimated. It is likely
that the first CRQCs (Cryptographically Relevant Quantum Computers) will not be able to perform short-exposure quantum
attacks.</p>
<table><thead><tr><th>+ Candidate quantum-resistant signature algorithms ordered by largest to smallest NIST Level V signature size</th></tr></thead><tbody>
<tr><td>Signature Algorithm</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Lamport_signature" target="_blank">Lamport signature</a></td></tr>
<tr><td><a href="https://eprint.iacr.org/2011/191.pdf" target="_blank">Winternitz signature</a></td></tr>
<tr><td><a href="https://sphincs.org/data/sphincs+-r3.1-specification.pdf" target="_blank">SPHINCS+ Rd. 3.1 (FIPS 205 - SLH-DSA)</a></td></tr>
<tr><td><a href="https://eprint.iacr.org/2011/484.pdf" target="_blank">XMSS</a><ref name="xmss">XMSS, which is based on Winternitz, uses a value of 108</td></tr>
<tr><td><a href="https://pq-crystals.org/dilithium/" target="_blank">CRYSTALS-Dilithium (FIPS 204 - ML-DSA)</a></td></tr>
<tr><td><a href="https://eprint.iacr.org/2014/457.pdf" target="_blank">pqNTRUsign</a></td></tr>
<tr><td><a href="https://falcon-sign.info" target="_blank">FALCON (FIPS 206 - FN-DSA)</a></td></tr>
<tr><td><a href="https://eprint.iacr.org/2022/1155.pdf" target="_blank">HAWK</a></td></tr>
<tr><td><a href="https://sqisign.org" target="_blank">SQIsign</a></td></tr>
<tr><td><a href="https://eprint.iacr.org/2024/760.pdf" target="_blank">SQIsign2D-West</a></td></tr>
<tr><td><a href="https://eprint.iacr.org/2023/436.pdf" target="_blank">SQIsignHD</a></td></tr>
</tbody></table>
<p>As shown, supersingular elliptic curve quaternion isogeny signature algorithms represent the state of the art in
post-quantum cryptography, beyond lattice cryptography alone, especially when key and signature length are major
constraints. This makes inclusion of SQIsign attractive, however its performance is roughly 100,000 times slower than ECC,
which is prohibitive in blockchain contexts. Meanwhile, SPHINCS+ and CRYSTALS-Dilithium signatures are already approved
and have achieved broader community consensus. FALCON signatures are also NIST approved.</p>
<p>In comparison, the size of currently used signature algorithms are:</p>
<ul>
<li>ECDSA: 70-72 bytes</li>
<li>Schnorr: 64 bytes</li>
</ul>
<p>In comparison to inception date, secp256k1 <a href="https://www.secg.org/SEC1-Ver-1.0.pdf" target="_blank">was originally specified in 2000</a>.</p>
<p>One consideration for choosing an algorithm is its maturity. secp256k1 was already 8 years old by the time it was
chosen as Bitcoin's curve. Isogeny cryptography when it was first introduced was broken over a weekend.</p>
<p>Signature verification speed as it compares to Schnorr or ECDSA isn't seen as high a consideration as signature size
due to block space being the primary fee constraint. As a P2QRH implementation materializes, a benchmark will be added
for performance comparison.</p>
<p>An additional consideration is security level. Longer signature sizes provide more security. NIST has standardized five
security levels for post-quantum cryptography. NIST security level I provides security equivalent to 128-bit keys, and
security level V provides 256-bit security.</p>
<h2> Test Vectors and Reference Code </h2>
<p>TBD</p>
<h2> Related Work </h2>
<p>It is worth noting by way of comparison that
[https://ethresear.ch/t/how-to-hard-fork-to-save-most-users-funds-in-a-quantum-emergency/18901 Vitalik Buterin's
proposed solution] in an Ethereum quantum emergency is quite different from the approach in this BIP. His plan involves
a hard fork of the chain, reverting all blocks after a sufficient amount of theft, and using STARKs based on BIP-32
seeds to act as the authoritative secret when signing. These measures are deemed far too heavy-handed for Bitcoin.</p>
<p>P2QRH and MAST (Merkelized Abstract Syntax Tree) <a href="/114" target="_blank">BIP-114</a>,
and related BIPs <a href="/116" target="_blank">BIP-116</a>, <a href="/117" target="_blank">BIP-117</a>,
share the idea of committing to a Merkle tree of scripts. While MAST was never activated, taproot
<a href="/341" target="_blank">BIP-341</a> incorporated this idea of a Merkle tree of
scripts into its design. P2QRH inherits this capability from taproot because P2QRH is simply taproot with the key-spend
path removed. As a result, P2QRH does have the taproot internal key or tweak key, instead P2QRH commits directly to the
Merkle tree of scripts.</p>
<p>Below we attempt to summarize some of the ideas discussed on the Bitcoin Bitcoin-Dev that relate to P2QRH.</p>
<p>The idea of a taproot but with the key-spend path removed has been discussed a number of times in the Bitcoin community.
<a href="https://gnusha.org/pi/bitcoindev/CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com/" target="_blank">OP_CAT Makes Bitcoin Quantum Secure</a>
notes that if we disable the key-spend in taproot and activated CAT <a href="https://github.com/bitcoin/bips/blob/master/bip-0347.mediawik" target="_blank">BIP-347</a>,
we could achieve quantum resistance by using Lamport signatures with CAT. Lamport and WOTS (Winternitz One-Time Signatures) built from CAT
are quantum resistant but are one-time signatures. This means that if you sign twice for the same public key, you leak your secret key.
This would require major changes to wallet behavior and would represent a significant security downgrade.
<a href="https://groups.google.com/g/bitcoindev/c/8O857bRSVV8/m/rTrpeFjWDAAJ" target="_blank">Trivial QC signatures with clean upgrade path</a> and
<a href="https://groups.google.com/g/bitcoindev/c/oQKezDOc4us/m/T1vSMkZNAAAJ" target="_blank">Re: P2QRH / BIP-360 Update</a> discusses the idea of
taproot but with the future ability to disable the key-spend path.
The design of P2QRH is partly inspired by these discussions as P2QRH can be understood as P2TR without the key-spend path.</p>
<p>Commit-reveal schemes such as
<a href="https://gnusha.org/pi/bitcoindev/1518710367.3550.111.camel@mmci.uni-saarland.de/" target="_blank"> Re: Transition to post-quantum (2018)</a>
and <a href="https://groups.google.com/g/bitcoindev/c/LpWOcXMcvk8/m/YEiH-kTHAwAJ" target="_blank">Post-Quantum commit / reveal Fawkescoin variant as a soft fork (2025)</a>
have been proposed as a way to safely spend bitcoins if CRQCs become practical prior to Bitcoin adopting achieving quantum resistance.
The essential idea is to leverage the fact that a CRQC can only learn your private key after a user has revealed their public key.
Thus, Bitcoin could fork in an alternative way to spend an output that would leverage this property.
Spending via commit-reveal would require two steps, first the user's commits on-chain to their public key along with a set of outputs the user wishes
to spend to. Then, in reveal, the user sign and reveals their public key. While CRQC might be able to generate competing signatures it can not produce
a commitment to the user's public key earlier than the user's commitment as it does not learn it until the reveal step.</p>
<p>Commit-reveal schemes can only be spent from and to outputs that are not vulnerable to long-exposure quantum attacks, such as
P2PKH, P2SK, P2WPKH, etc... To use tapscript outputs with this system either a soft fork could disable the key-spend path of P2TR outputs
or P2QRH could be used here as it does not have a key-spend path and thus is not vulnerable to long-exposure quantum attacks.</p>
<h2> References </h2>
<ul>
<li><a href="https://groups.google.com/g/bitcoindev/c/Aee8xKuIC2s/m/cu6xej1mBQAJ" target="_blank">Mailing list discussion</a></li>
<li><a href="https://delvingbitcoin.org/t/proposing-a-p2qrh-bip-towards-a-quantum-resistant-soft-fork/956?u=cryptoquick" target="_blank">Delving Bitcoin discussion</a></li>
<li><a href="https://bitcoinops.org/en/newsletters/2024/06/14/" target="_blank">Bitcoin Optech newsletter</a></li>
<li><a href="https://bitcoinops.org/en/podcast/2024/06/18/" target="_blank">draft-bip-for-quantum-safe-address-format Bitcoin Optech discussion transcript</a></li>
</ul>
<h2> Footnotes </h2>
<ol>
<li><a href="http://127.0.0.1:1111/360/#cite_ref_1">^</a> <strong>Why not have CHECKSIG infer the algorithm based on signature size?</strong> Each of the three signature algorithms, Schnorr, ML-DSA, and SLH-DSA, have unique signature sizes. The problem with using signature size to infer algorithm is that spender specifies the signature. This would allow a public key which was intended to be verified by Schnorr to be verified using ML-DSA as the spender specified a ML-DSA signature. Signature algorithms are not often not secure if you can mix and match public key and signature across algorithms.</li>
<li><a href="http://127.0.0.1:1111/360/#cite_ref_2">^</a> Bas Westerbaan (2025), <a href="https://groups.google.com/g/bitcoindev/c/5Ff0jdQPofo" target="_blank">jpeg resistance of various post-quantum signature schemes</a></li>
<li><a href="http://127.0.0.1:1111/360/#cite_ref_3">^</a> <strong>Why set the last bit of c[0] to one?</strong> Consider a faulty implementation that deserializes the <em>leaf version</em> as c[0] rather than c[0] &amp; 0xfe for both P2TR and P2QRH. If they test against P2QRH outputs and require that last bit is 1, this deserialization bug will cause an immediate error.</li>
<li><a href="http://127.0.0.1:1111/360/#cite_ref_4">^</a> If m &gt;= 8, then the compact size will use 3 bytes rather than 1 byte</li>
</ol>
<h2> Changelog </h2>
<p>To help implementors understand updates to this BIP, we keep a list of substantial changes.</p>
<ul>
<li>2025-07-07 - P2QRH is now a P2TR with the vulnerable key-spend path disabled. Number of PQ signature algorithms supported reduced from three to two. PQ signature algorithm support is now added via opcodes or tapleaf version.</li>
<li>2025-03-18 - Correct inconsistencies in commitment and attestation structure. Switch from merkle tree commitment to sorted vector hash commitment. Update descriptor format.</li>
<li>2025-03-12 - Add verification times for each algorithm. 256 -&gt; 128 (NIST V -&gt; NIST I). Add key type bitmask. Clarify multisig semantics.</li>
<li>2025-02-23 - More points of clarification from review. Update dead link.</li>
<li>2025-01-20 - Remove SQIsign from consideration due to significant performance concerns. Refactor language from long-range attack to long-exposure so as to not be confused with the language around block re-org attacks.</li>
<li>2024-12-18 - Assigned BIP number.</li>
<li>2024-12-13 - Update to use merkle tree for attestation commitment. Update LR &amp; SR quantum attack scenarios.</li>
<li>2024-12-01 - Add details on attestation structure and parsing.</li>
<li>2024-10-21 - Replace XMSS with CRYSTALS-Dilithium due to NIST approval and size constraints.</li>
<li>2024-09-30 - Refactor the ECC vs PoW section. Swap quitness for attestation.</li>
<li>2024-09-29 - Update section on PoW to include partial-preimage.</li>
<li>2024-09-28 - Add Winternitz, XMSS signatures, and security assumption types to PQC table. Omit NIST Level I table. Add spend script specification. Add revealed public key scenario table.</li>
<li>2024-09-27 - Initial draft proposal</li>
</ul>
<h2> Acknowledgements </h2>
<p>This document is inspired by <a href="/341" target="_blank">BIP-341</a>, which introduced
the design of the P2TR (Taproot) output type using Schnorr signatures.</p>
<p>Much gratitude to my co-founder, Kyle Crews for proofreading and editing, to David Croisant, who suggested the name
"QuBit", and Guy Swann for pointing out the earlier name for the attestation, "quitness", was imperfect. The
attestation was later discarded when Ethan Heilman joined as co-author, whom I'm incredibly grateful to for
transforming this BIP into something far more congruent with existing Bitcoin design. Thank you as
well to those who took the time to review and contribute, including Jeff Bride, Adam Borcany, Antoine Riard, Pierre-Luc
Dallaire-Demers, Mark Erhardt, Joey Yandle, Jon Atack, Armin Sabouri, Jameson Lopp, Murchandamus, and Vojtěch Strnad.</p>

        </article>
    </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated:</p>
                    <p class="font-bold">July 2025</p>
                </div>

                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website
                    makes no claim of ownership.</p>
            </div>
        </div>
    </div>
</body>
</html>

