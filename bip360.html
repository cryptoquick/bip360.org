<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="BIP 360 - Pay to Quantum Resistant Hash" />
    <meta name="keywords" content="bitcoin, bitcoin improvement proposals, bip, bips, static, share" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="BIP 360: Pay to Quantum Resistant Hash" />
    <meta property="og:description" content="BIP 360 - Pay to Quantum Resistant Hash" />
    <meta property="og:image" content="https://bips.dev/og-bips-dev.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="BIP 360: Pay to Quantum Resistant Hash" />
    <meta name="twitter:description" content="BIP 360 - Pay to Quantum Resistant Hash" />
    <meta name="twitter:creator" content="@cryptoquick" />
    <meta name="twitter:image" content="https://bips.dev/og-bips-dev.png" />

    <title>BIP 360: Pay to Quantum Resistant Hash</title>

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="/style.css" />

    <script>
        // setup plausible function for custom events
        window.plausible = window.plausible || function () { (window.plausible.q = window.plausible.q || []).push(arguments) }

        // setup and initialize dark mode
        // https://tailwindcss.com/docs/dark-mode
        window.setTheme = function () {
            if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark')
            } else {
                document.documentElement.classList.remove('dark')
            }
        }
        window.setTheme();
    </script>

    <style>
        /* variables to override on pagefind */
        /* https://pagefind.app/docs/ui-usage/#customising-the-styles */
        /* values are from tailwind: https://tailwindcss.com/docs/customizing-colors */
        :root {
            --pagefind-ui-primary: #334155;
            --pagefind-ui-text: #334155;
            --pagefind-ui-background: #ffffff;
            --pagefind-ui-border-width: 1px;
            --pagefind-ui-border-radius: 4px;
        }

        html.dark {
            --pagefind-ui-primary: #d1d5db;
            --pagefind-ui-text: #d1d5db;
            --pagefind-ui-background: #18181b;
            --pagefind-ui-border: #152028;
        }

        mark {
            background-color: #ff9900 !important;
            color: #6b7280 !important;
        }

        .text-btc-orange {
            color: #ff9900 !important;
        }
    </style>
</head>

<body class="bg-white dark:bg-zinc-900">
    <header class="bg-white dark:bg-zinc-800 border-gray-200 dark:border-gray-700 border-b border-b-gray-200 dark:border-b-gray-700">
        <nav class="flex items-center justify-center p-6 lg:px-8" aria-label="Global">
            <!-- <div class="flex lg:flex-1">&nbsp;</div> -->
            <div class="lg:flex lg:gap-x-12">
                <a href="index.html" class="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-btc-orange nav-link" style="text-decoration: none;">INTRO</a>
                <a href="bip360.html"
                    class="text-sm/6 font-semibold text-btc-orange nav-link" style="text-decoration: none;">BIP360</a>
                <a href="https://github.com/cryptoquick/bips/blob/hourglass/bip-hourglass.mediawiki" target="_blank"
                    class="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-btc-orange nav-link" style="text-decoration: none;">HOURGLASS</a>
                <a href="media.html"
                    class="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-btc-orange nav-link" style="text-decoration: none;">MEDIA</a>
            </div>
            <!-- <div class="hidden lg:flex lg:flex-1 lg:justify-end">&nbsp;</div> -->
        </nav>
    </header>
    <div class="container mx-auto flex justify-center">
        <div data-pagefind-body
            class="min-w-full max-w-full lg:min-w-[1000px] lg:max-w-[1000px] px-6 py-2 space-y-10 text-slate-700 dark:text-gray-300">

            <div class="flex flex-col space-y-4 pt-4 md:pt-8">
                <div class="flex justify-between">
                    <div class="flex">
                        <svg id="toggleDark_light" class="hidden dark:block w-6 h-6 hover:cursor-pointer"
                            onclick="localStorage.theme = 'light'; window.setTheme()" xmlns="http://www.w3.org/2000/svg"
                            fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
                        </svg>
                        <svg id="toggleDark_dark" class="flex dark:hidden w-6 h-6 hover:cursor-pointer"
                            onclick="localStorage.theme = 'dark'; window.setTheme()" xmlns="http://www.w3.org/2000/svg"
                            fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
                        </svg>
                    </div>
                </div>
                <div class="flex flex-col space-y-2">
                    <div data-pagefind-weight="10" class="text-2xl font-extrabold">BIP 360: Pay to Quantum Resistant
                        Hash</div>
                    <div class="flex justify-between">
                        <div class="text-xl font-semibold">2024-12-18</div>
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;cryptoquick&#x2F;bips&#x2F;blob&#x2F;p2qrh&#x2F;bip-0360.mediawiki"
                            target="_blank">View on GitHub</a>
                    </div>
                </div>

                <article
                    class="max-w-none prose prose-lg prose-zinc prose-p:leading-relaxed prose-a:font-bold prose-a:underline prose-a:decoration-2 prose-a:decoration-bitcoin prose-pre:bg-zinc-200 prose-pre:text-zinc-800 dark:prose-invert dark:prose-pre:bg-zinc-600 dark:prose-pre:text-white">
                    <pre><code>  BIP: 360
  Title: Pay to Quantum Resistant Hash
  Layer: Consensus (soft fork)
  Author: Hunter Beast &lt;hunter@surmount.systems&gt;
  Comments-Summary: No comments yet.
  Comments-URI: https:&#x2F;&#x2F;github.com&#x2F;bitcoin&#x2F;bips&#x2F;wiki&#x2F;Comments:BIP-0360
  Status: Draft
  Type: Standards Track
  Created: 2024-12-18
  License: BSD-3-Clause
</code></pre>
                    <h2> Introduction </h2>
                    <h3> Abstract </h3>
                    <p>This document proposes the introduction of a new output type using signatures based on
                        Post-Quantum Cryptography (PQC).
                        This approach for adding a post-quantum secure output type does not require a hard fork or block
                        size increase.</p>
                    <h3> Copyright </h3>
                    <p>This document is licensed under the 3-clause BSD license.</p>
                    <h3> Motivation </h3>
                    <p>The primary threat to Bitcoin from Cryptoanalytically-Relevant Quantum Computers (CRQCs)<ref
                            name="CRQC">
                            A Cryptoanalytically-Relevant Quantum Computer is an <em>object</em> which is only loosely
                            defined by <em>characteristics</em> in quantum physics as of today. It could be understood
                            in the context of this BIP and in bitcoin that it's a <em>hardware-agnostic</em> computer
                            supposed to have the architecture to keep <em>coherent</em> a sufficient number of logical
                            qubits to be able to run the Shor algorithm in an efficient fashion.</ref>
                        is their potential to break the cryptographic assumptions of Elliptic Curve Cryptography (ECC),
                        which secures Bitcoin's signatures and Taproot
                        commitments. Specifically, <a href="https://arxiv.org/pdf/quant-ph/0301141"
                            target="_blank">Shor's algorithm</a> enables a CRQC to solve the
                        Discrete Logarithm Problem (DLP) exponentially faster than classical methods<ref name="shor">
                            Shor's algorithm is
                            believed to need 10^8 operations to break a 256-bit elliptic curve public key.</ref>,
                        allowing the derivation of
                        private keys from public keys-- a process referred to here as quantum key decryption.
                        <ref name="quantum-key-decryption">Meaning, deriving private keys from public keys via Shor's
                            algorithm</ref>
                        Importantly, simply doubling the public
                        key length (e.g., using a hypothetical secp512k1 curve) would only make deriving the private key
                        twice as hard,
                        offering insufficient protection. The computational complexity of this attack is further
                        explored in
                        <a href="https://pubs.aip.org/avs/aqs/article/4/1/013801/2835275/The-impact-of-hardware-specifications-on-reaching"
                            target="_blank"><em>The impact of hardware specifications on reaching quantum advantage in
                                the fault-tolerant regime</em></a>.
                    </p>
                    <p>This proposal aims to mitigate these risks by introducing a Pay to Quantum Resistant Hash (P2QRH)
                        output type that
                        relies on PQC signature algorithms. By adopting PQC, Bitcoin can enhance its quantum
                        resistance without requiring a hard fork or block size increase.</p>
                    <p>The vulnerability of existing Bitcoin addresses<ref name="address-vulnerability">A vulnerable
                            Bitcoin address is any
                            <em>scriptPubKey</em> type that exposes an elliptic curve public key as <em>raw bytes</em>
                            in a <em>block</em>, making it susceptible
                            to private key derivation through Shor's algorithm. This includes P2PK outputs and any
                            script that contains an
                            unprotected public key.
                        </ref> is detailed in
                        <a href="https://web.archive.org/web/20240715101040/https://www2.deloitte.com/nl/nl/pages/innovatie/artikelen/quantum-computers-and-the-bitcoin-blockchain.html"
                            target="_blank">this Deloitte report</a>.
                        The report estimates that in 2020 approximately 25% of the Bitcoin supply is held within
                        addresses vulnerable to
                        quantum attack. As of the time of writing, that number is now closer to 20%. Independently,
                        Bitcoin developer Pieter
                        Wuille <a
                            href="https://web.archive.org/web/20220531184542/https://twitter.com/pwuille/status/1108085284862713856"
                            target="_blank">reasons</a> even more addresses might be vulnerable, representing
                        5M to 10M bitcoin.
                    </p>
                    <p>Ordinarily, when a transaction is signed, the public key is explicitly stated in the input
                        script. This means that the
                        public key is exposed on the blockchain when the transaction is spent, making it vulnerable to
                        quantum attack until
                        it's mined. One way to mitigate this is to submit the transaction directly to a mining pool,
                        bypassing the mempool.
                        This process is known as an out-of-band transaction or a private mempool. In this case, the
                        mining pool must be trusted
                        not to reveal the transaction public key to attackers. The problem with this approach is that it
                        requires a trusted
                        third party, which the P2QRH proposal aims to avoid. It also doesn't account for block reorg
                        attacks, which would
                        reveal public keys in blocks that were once mined but are now orphaned and must be mined again.
                        Additionally,
                        it depends on the mining pool whether they reveal their block template to either the public or
                        to miners.</p>
                    <p>Not having public keys exposed on-chain is an important step for quantum security. Otherwise,
                        funds would need to be
                        spent to new addresses on a regular basis in order to prevent the possibility of a
                        "long-exposure CRQC attack" recovering
                        the key behind high-value addresses. A long-exposure quantum attack can be considered one
                        performed with chain data, such
                        as that from a used address or one encoded in a spend script. This is likely to be more common
                        early on, as early
                        quantum computers must be run for longer in order to overcome errors caused by noise. A
                        "short-exposure quantum attack"
                        would be one performed on keys in the mempool, which is seen as much more difficult given the
                        block time, and so it
                        requires more sophisticated CRQCs.<ref name="short-exposure">
                            In the paper
                            <a href="https://arxiv.org/pdf/2306.08585" target="_blank">How to compute a 256-bit elliptic
                                curve private key with only 50 million Toffoli gates</a>
                            the authors estimate that a CRQC with 28 million superconducting physical qubits would take
                            8.3 seconds to calculate a
                            256-bit key, while a CRQC with 6.9 million physical qubits would take 58 seconds. This
                            implies that a CRQC with 4x as
                            many qubits would be roughly 7 times faster.
                        </ref>
                    </p>
                    <p>As the value being sent increases, so too should the fee in order to commit the transaction to
                        the chain as soon as
                        possible. Once the transaction is mined, it makes useless the public key revealed by spending a
                        UTXO, so long as it is
                        never reused.</p>
                    <p>It is proposed to implement a Pay to Quantum Resistant Hash (P2QRH) output type that relies on a
                        PQC signature
                        algorithm. This new output type protects transactions submitted to the mempool and helps
                        preserve the free market by
                        preventing the need for private, out-of-band mempool transactions.</p>
                    <p>The following table is intended to inform the average Bitcoin user whether their bitcoin is
                        vulnerable to a long-exposure
                        quantum attack:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>+ Output types vulnerable to long-exposure attacks on unspent addresses</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Type</td>
                            </tr>
                            <tr>
                                <td>P2PK</td>
                            </tr>
                            <tr>
                                <td>P2PKH</td>
                            </tr>
                            <tr>
                                <td>P2MS</td>
                            </tr>
                            <tr>
                                <td>P2SH</td>
                            </tr>
                            <tr>
                                <td>P2WPKH</td>
                            </tr>
                            <tr>
                                <td>P2WSH</td>
                            </tr>
                            <tr>
                                <td>P2TR</td>
                            </tr>
                            <tr>
                                <td>P2QRH</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>ยน Funds in P2PKH, P2SH, P2WPKH, and P2WSH outputs become vulnerable to long-exposure quantum
                        attacks when their input script is revealed. An address is no longer safe against long-exposure
                        quantum attacks after funds from it have been spent.</p>
                    <p>It should be noted that Taproot outputs are vulnerable in that they encode a 32-byte x-only
                        public key, from which a
                        full public key can be reconstructed.</p>
                    <p>If a CRQC recovers an extended public key (xpub), including its chain code, it can derive all
                        non-hardened child public
                        keys by guessing or iterating through child indexes, as allowed by BIP-32's non-hardened
                        derivation. With Shor's
                        algorithm, the CRQC could then compute the corresponding non-hardened child private keys
                        directly from those public keys,
                        without needing the extended private key (xprv) or an exposed child private key. Hardened child
                        keys remain secure since
                        they cannot be derived from the xpub alone. However, if the xprv is exposed, then all child
                        private keys--both hardened
                        and non-hardened--become vulnerable. Thus, in a quantum context, the xpub alone is sufficient to
                        expose all non-hardened
                        child private keys.</p>
                    <h4> Long Exposure and Short Exposure Quantum Attacks </h4>
                    <p>A Long Exposure Quantum Attack is an attack in which the public key has been exposed on the
                        blockchain for an extended
                        period of time, giving an attacker ample opportunity to break the cryptography. This affects:
                    </p>
                    <ul>
                        <li>P2PK outputs (Satoshi's coins, CPU miners, starts with 04)</li>
                        <li>Reused addresses (any type, except P2QRH)</li>
                        <li>Taproot addresses (starts with bc1p)</li>
                        <li>Extended public keys, commonly known as "xpubs"</li>
                        <li>Wallet descriptors</li>
                    </ul>
                    <p>A Short Exposure Quantum Attack is an attack that must be executed quickly while a transaction is
                        still in the mempool,
                        before it is mined into a block. This affects:</p>
                    <ul>
                        <li>Any transaction in the mempool (except for P2QRH)</li>
                    </ul>
                    <p>Short-exposure attacks require much larger, more expensive CRQCs since they must be executed
                        within the short window
                        before a transaction is mined. Long-exposure attacks can be executed over a longer timeframe
                        since the public key remains
                        exposed on the blockchain indefinitely.</p>
                    <p>Coinbase outputs to P2PK keys go as far as block 200,000, so there are, at the time of writing,
                        1,723,848 coins that
                        are vulnerable from the first epoch in P2PK outputs alone. The majority of these have a block
                        reward of 50 coins each,
                        and there are roughly 34,000 distinct P2PK scripts that are vulnerable. These coins can be
                        considered
                        "Satoshi's Shield." Any addresses with a balance of less than the original block subsidy of 50
                        coins can be considered
                        cryptoeconomically incentive incompatible to capture until all of these are mined, and these
                        addresses serve to provide
                        time to transition Bitcoin to implement post-quantum security.</p>
                    <p>It's for the above reason that, for those who wish to be prepared for quantum emergency, it is
                        recommended that no more
                        than 50 bitcoin are kept under a single, distinct, unused Native SegWit (P2WPKH, "bc1q") address
                        at a time. This is
                        assuming that the attacker is financially motivated instead of, for example, a nation state
                        looking to break confidence
                        in Bitcoin. Independently, this assumes that other vulnerable targets such as central banks have
                        upgraded their
                        cryptography by this time.</p>
                    <p>The Commercial National Security Algorithm Suite (CNSA) 2.0 has a timeline for software and
                        networking equipment to be
                        upgraded by 2030, with browsers and operating systems fully upgraded by 2033. According to NIST
                        IR 8547, Elliptic Curve
                        Cryptography is planned to be disallowed within the US federal government after 2035. An
                        exception is made for hybrid
                        cryptography, which is the use of ECC and post-quantum algorithms together.</p>
                    <p>Although the main threat posed by CRQCs is to the signatures used in Bitcoin, a smaller threat is
                        to Bitcoin's hash
                        algorithms. In particular, while a CRQC could use <a
                            href="https://en.wikipedia.org/wiki/Grover's_algorithm" target="_blank">Grover's
                            algorithm</a>
                        to gain a quadratic speedup on brute-force attacks on the hash functions used in Bitcoin, a
                        significantly more powerful
                        CRQC is needed for these attacks to meaningfully impact Bitcoin. For instance, a preimage attack
                        on
                        HASH160 <ref name="hash160">Used by P2PKH, P2SH, and P2WPKH addresses, though not P2WSH because
                            it uses 256-bit hashes.</ref>
                        using Grover's algorithm would require at least 10^24 quantum operations. As for Grover's
                        application to mining, see
                        <a href="https://quantumcomputing.stackexchange.com/a/12847" target="_blank">Sam Jaques' post on
                            this</a>.
                    </p>
                    <h3> Rationale </h3>
                    <p>This is the first in a series of BIPs under a QuBit soft fork. A qubit is a fundamental unit of
                        quantum computing, and
                        the capital B refers to Bitcoin. The name QuBit also rhymes to some extent with SegWit.</p>
                    <p>It is proposed to use SegWit version 3. This results in addresses that start with bc1r, which
                        could be a useful way to
                        remember that these are quantum (r)esistant addresses. This is referencing the lookup table
                        under
                        <a href="/173" target="_blank">BIP-173</a>.
                    </p>
                    <p>P2QRH is meant to be implemented on top of P2TR, combining the security of classical Schnorr
                        signatures along with
                        post-quantum cryptography. This is a form of hybrid cryptography such that no regression in
                        security is presented
                        should a vulnerability exist in one of the signature algorithms used. One key distinction
                        between P2QRH and P2TR
                        however is that P2QRH will encode a hash of the public key. This is a significant deviation from
                        how Taproot works by
                        itself, but it is necessary to avoid exposing public keys on-chain where they are vulnerable to
                        attack.</p>
                    <p>P2QRH uses a 32-byte HASH256 (specifically SHA-256 twice-over) of the public key to reduce the
                        size of new outputs and
                        also to increase security by not having the public key available on-chain. While HASH256 uses
                        double SHA-256 like
                        Bitcoin's Proof of Work, this does not meaningfully increase quantum resistance compared to
                        single SHA-256, as both
                        provide approximately 2^128 security against Grover's algorithm. The practical impact of quantum
                        attacks on SHA-256
                        remains theoretical since quantum circuits for SHA-256 are still theoretical, but using the same
                        hash function as
                        Proof of Work maintains consistency with Bitcoin's existing security model. This hash serves as
                        a minimal cryptographic
                        commitment to a public key in the style of a
                        <a href="/141" target="_blank">BIP-141 witness program</a>.
                        Because it goes into the scriptPubKey, it does not receive a witness or attestation discount.
                    </p>
                    <p>Post-quantum public keys are generally larger than those used by ECC, depending on the security
                        level.
                        Originally BIP-360 proposed NIST Level V, 256-bit security, but this was changed to NIST Level
                        I, 128-bit security
                        due to concerns over the size of the public keys, the time it would take to verify signatures,
                        and being generally
                        deemed "overkill".</p>
                    <p>Support for FALCON signatures will be introduced first, with the intention of adding other
                        post-quantum
                        algorithms as they are approved. By way of comparison, FALCON signatures are roughly 20x larger
                        than Schnorr signatures.
                        FALCON has recently been approved by NIST. NIST approval streamlines implementations through
                        establishing
                        consensus in the scientific and developer community. This means, to maintain present transaction
                        throughput, an
                        increase in the witness discount will likely be desired in a QuBit soft fork. That will be
                        specified in a future QuBit
                        BIP.</p>
                    <p>An increase in the witness discount must not be taken lightly. It must be resistant to
                        applications that might take
                        advantage of this discount (e.g., storage of arbitrary data as seen with "inscriptions") without
                        a corresponding
                        increase in economic activity. An increase in the witness discount would not only impact node
                        runners but those with
                        inscriptions would also have the scarcity of their non-monetary assets affected. The only way to
                        prevent these effects
                        while also increasing the discount is to have a completely separate witness--a "quantum
                        witness." Because it is meant
                        only for public keys and signatures, we call this section of the transaction the attestation.
                    </p>
                    <p>Additionally, it should be noted, whether an output with a P2QRH spend script corresponds to a
                        PQC signature is not
                        known until the output is spent.</p>
                    <p>While it might be seen as a maintenance burden for Bitcoin ecosystem devs to go from a single
                        cryptosystem
                        implementation to three additional distinct PQC cryptosystems--and it most certainly is--the
                        ramifications of a chain
                        broken through extrinsic factors should provide sufficient motivation. An increase in software
                        maintenance everywhere
                        signatures are used should be seen as an acceptable compromise for maintained integrity of
                        Bitcoin transfers during a
                        regime of quantum advantage.</p>
                    <p>The inclusion of these three cryptosystems: SPHINCS+, CRYSTALS-Dilithium, and FALCON have various
                        advocates
                        within the community due to their varying security assumptions. Hash-based cryptosystems are
                        more conservative,
                        time-tested, and well-reviewed. Lattice cryptography is relatively new and introduces novel
                        security assumptions to
                        Bitcoin, but their signatures are smaller and might be considered by some to be an adequate
                        alternative to hash-based
                        signatures.</p>
                    <p>The reason multiple cryptosystems are included is in the interest of supporting hybrid
                        cryptography, especially for
                        high value outputs, such as cold wallets used by exchanges. To improve the viability of the
                        activation client and
                        adoption by wallets and libraries, a library akin to libsecp256k1 will be developed. This
                        library, libbitcoinpqc,
                        will support the new PQC cryptosystems and can be used as a reference for other language-native
                        implementations.</p>
                    <p>In the distant future, following the implementation of the P2QRH output type in a QuBit soft
                        fork, there will likely
                        be a need for Pay to Quantum Secure (P2QS) addresses. A distinction is made between cryptography
                        that's merely resistant
                        to quantum attack, and cryptography that's secured by specialized quantum hardware. P2QRH is
                        resistant to quantum
                        attack, while P2QS is quantum secure. These will require specialized quantum hardware for
                        signing, while still
                        <a href="https://quantum-journal.org/papers/q-2023-01-19-901/" target="_blank">using public keys
                            that are verifiable via classical means</a>.
                    </p>
                    <p>While P2QRH lacks features like signature aggregation for smaller transactions, it offers a
                        pragmatic first step
                        toward quantum resistance. Future BIPs can add enhancements like P2QS, signature aggregation,
                        and possibly full
                        BIP-32 compatibility once tested and viable. Until quantum cryptography hardware and advanced
                        schemes are widespread,
                        P2QRH provides meaningful protection against quantum threats without delaying deployment for a
                        perfect solution.</p>
                    <p>Additional follow-on BIPs will be needed to implement P2QS, signature aggregation, and full
                        BIP-32 compatibility
                        (if possible) <ref name="bip-32">BIP-32 relies on elliptic curve operations to derive keys from
                            xpubs to support
                            watch-only wallets, which PQC schemes may not support.</ref>. However, until specialized
                        quantum cryptography hardware
                        is widespread and signature aggregation schemes are thoroughly vetted, P2QRH addresses should be
                        an adequate
                        intermediate solution that provides meaningful protection against quantum threats.</p>
                    <h2> Specification </h2>
                    <p>We define the signature scheme and transaction structure as follows.</p>
                    <h3> Descriptor Format </h3>
                    <p>To integrate P2QRH into existing wallet software and scripts, we introduce a new output
                        descriptor function
                        <code>qrh()</code>. This function represents a P2QRH output, similar to how <code>wpkh()</code>
                        and <code>tr()</code>
                        are used for P2WPKH and P2TR outputs, respectively.
                    </p>
                    <p>The <code>qrh()</code> function takes a threshold value and multiple key specifications grouped
                        by key type. The format is:</p>
                    <pre><code>  qrh(threshold, keytype(0x01, [hash1, hash2, ...]), keytype(0x02, [hash1, hash2, ...]), ...)
</code></pre>
                    <p>Where:</p>
                    <ul>
                        <li><code>threshold</code> is an integer specifying the minimum number of signatures required
                        </li>
                        <li><code>keytype</code> is the hex value representing the key type (0x01 for secp256k1, 0x02
                            for FALCON-512, 0x04 for CRYSTALS-Dilithium Level I, 0x08 for SPHINCS+-128s)</li>
                        <li><code>&lt;a href="hash1," target="_blank"&gt;hash2, ...&lt;/a&gt;</code> is an array of
                            HASH256 hashes of public keys for the corresponding algorithm type</li>
                    </ul>
                    <p>For example:</p>
                    <pre><code>  qrh(3, keytype(0x01, hash256(secp256k1_pubkey1), hash256(secp256k1_pubkey2), hash256(secp256k1_pubkey3), secp256k1_pubkey4_hash, secp256k1_pubkey5_hash),
      keytype(0x02, hash256(falcon_pubkey1), hash256(falcon_pubkey2), hash256(falcon_pubkey3), falcon_pubkey4_hash, falcon_pubkey5_hash),
      keytype(0x04, hash256(dilithium_pubkey1), hash256(dilithium_pubkey2), hash256(dilithium_pubkey3), dilithium_pubkey4_hash, dilithium_pubkey5_hash),
      keytype(0x08, hash256(sphincs_pubkey1), hash256(sphincs_pubkey2), hash256(sphincs_pubkey3), sphincs_pubkey4_hash, sphincs_pubkey5_hash))
</code></pre>
                    <p>This represents a 3-of-5 multisig for each key type, with a total of 20 keys: 5 keys per type (3
                        full public keys and 2
                        hashes) across 4 different key types.</p>
                    <p>Internally, the descriptor computes the HASH256 of the concatenated HASH256 of all the
                        quantum-resistant public keys,
                        with the threshold and key type bitmask prepended. For each key in the descriptor:</p>
                    <ul>
                        <li>If it is already a hash (indicated in the descriptor), it is used directly</li>
                        <li>If it is a public key, HASH256 is applied to it first</li>
                    </ul>
                    <p>This approach ensures that all items in the vector are HASH256 values, whether they originated
                        from raw public keys or
                        were provided as hashes. During spending, this allows for selective disclosure of public keys,
                        where some keys can
                        remain hidden (represented only by their hashes) while others are fully revealed with their
                        corresponding public keys.
                        This flexibility is particularly valuable in multisig schemes where not all keys need to be
                        revealed to satisfy the
                        threshold requirement. At a minimum, there should be two different key types in a P2QRH output:
                        one key that makes use
                        of classical cryptography, and one that makes use of a PQC algorithm chosen within the wallet.
                    </p>
                    <p>Also, it's important to note that order of keys and hashes in the descriptor matters and is based
                        on the original
                        public key values, in addition to the key type. Additionally, qrh() does not compile to script,
                        but instead, describes
                        what's needed to compute the scriptPubKey hash commitment and also to reveal the attestation
                        needed to spend the
                        output.</p>
                    <h3> Address Format </h3>
                    <p>P2QRH uses SegWit version 3 outputs, resulting in addresses that start with <code>bc1r</code>,
                        following
                        <a href="/173" target="_blank">BIP-173</a>. Bech32 encoding maps version 3 to the
                        prefix <code>r</code>.
                    </p>
                    <p>Example P2QRH address:</p>
                    <p><code>bc1r...</code> (32-byte Bech32m-encoded HASH256 of the HASH256 of the public keys)</p>
                    <h3> ScriptPubKey </h3>
                    <p>The <code>scriptPubKey</code> for a P2QRH output is:</p>
                    <pre><code>  OP_PUSHNUM_3 OP_PUSHBYTES_32 &lt;nowiki&gt;&lt;hash&gt;&lt;&#x2F;nowiki&gt;
</code></pre>
                    <p>Where:</p>
                    <ul>
                        <li><code>OP_PUSHNUM_3</code> (<code>0x03</code>) indicates SegWit version 3.</li>
                        <li>
                            <nowiki>
                                <hash>
                            </nowiki> is the 32-byte HASH256 of the commitment, as defined in the Hash Commitment
                            section below.
                        </li>
                    </ul>
                    <h4> Key Type Bitmask </h4>
                    <p>The key type bitmask is a 1-byte value that indicates the type of key used in the commitment. It
                        is encoded as follows:</p>
                    <ul>
                        <li>0x01 - Key type 0 - secp256k1</li>
                        <li>0x02 - Key type 1 - FALCON-512</li>
                        <li>0x04 - Key type 2 - CRYSTALS-Dilithium Level I</li>
                        <li>0x08 - Key type 3 - SPHINCS+-128s</li>
                        <li>0x10 - Unused</li>
                        <li>0x20 - Unused</li>
                        <li>0x40 - Unused</li>
                        <li>0x80 - Reserved for if additional key types are added in the future</li>
                    </ul>
                    <p>Example key type bitmask using all supported key types:</p>
                    <pre><code>  0x01 | 0x02 | 0x04 | 0x08 = 0x0F
</code></pre>
                    <h4> Hash Commitment </h4>
                    <p>If there is only a single public key, the hash is computed as the HASH256 of the public key.</p>
                    <p>In order to support multiple keys, as in the context of multisig or singlesig hybrid
                        cryptography, the hash is
                        computed as a commitment to a vector of public key hashes:</p>
                    <ol>
                        <li>Sort the public keys first by key type, then by public key value</li>
                        <li>For each sorted public key, compute its HASH256</li>
                        <li>Concatenate all the public key hashes in sorted order</li>
                        <li>Prepend key type bitmask and threshold to the concatenated hashes</li>
                        <li>Compute the HASH256 of the result</li>
                    </ol>
                    <p>For example with 4 public keys:</p>
                    <pre><code>  &#x2F;&#x2F; First sort the public keys
  sorted_pubkeys = sort_by_key_type_and_value([pubkey1, pubkey2, pubkey3, pubkey4])
</code></pre>
                    <pre><code>  &#x2F;&#x2F; Then compute hashes of sorted keys
  h1 = HASH256(sorted_pubkeys[0])
  h2 = HASH256(sorted_pubkeys[1])
  h3 = HASH256(sorted_pubkeys[2])
  h4 = HASH256(sorted_pubkeys[3])
</code></pre>
                    <pre><code>  &#x2F;&#x2F; Concatenate all hashes
  concatenated = h1 &lt;nowiki&gt;||&lt;&#x2F;nowiki&gt; h2 &lt;nowiki&gt;||&lt;&#x2F;nowiki&gt; h3 &lt;nowiki&gt;||&lt;&#x2F;nowiki&gt; h4
</code></pre>
                    <pre><code>  commitment = key_type_bitmask &lt;nowiki&gt;||&lt;&#x2F;nowiki&gt; threshold &lt;nowiki&gt;||&lt;&#x2F;nowiki&gt; concatenated
</code></pre>
                    <pre><code>  hash = HASH256(commitment)
</code></pre>
                    <p>With sort_by_key_type_and_value defined as:</p>
                    <pre><code>  def sort_by_key_type_and_value(pubkeys):
      return sorted(pubkeys, key=lambda x: (x.key_type, x.public_key))
</code></pre>
                    <p>When spending, if a public key hash is provided in the attestation with an empty signature, that
                        hash will be used
                        directly in the vector computation rather than hashing the full public key. This allows unused
                        public keys to be
                        excluded from the transaction while still proving they were part of the original commitment.</p>
                    <p>The vector construction creates an efficient cryptographic commitment to multiple public keys
                        while enabling
                        selective disclosure.</p>
                    <p>A threshold is provided to indicate the number of signatures required to spend the output. This
                        is used in the
                        cryptographic commitment in the hash computation and revealed in the attestation when spent.</p>
                    <p>Only a single 32-byte X-only secp256k1 public key can be provided as key type 0. There are a few
                        reasons for this:</p>
                    <ol>
                        <li>It maintains Taproot compatibility by removing ambiguity which key is representative of the
                            Taptree.</li>
                        <li>It prevents abuse of public keys to store arbitrary data once quantum computing is
                            ubiquitous.</li>
                        <li>When a secp256k1 key is specified in the key type bitmask, how many keys it commits to is
                            unambiguous.</li>
                        <li>If multiple keys need to be committed to, they must be aggregated, which saves on
                            transaction size.</li>
                    </ol>
                    <p>This design maintains compatibility for <a href="/114" target="_blank">BIP-114</a>
                        Taproot Merkelized Alternative Script Tree (MAST) merkle root in the commitment, which makes
                        P2QRH a
                        quantum-resistant version of Taproot transactions. The TapScript itself must however be provided
                        in the witness,
                        as no script execution is allowed in the attestation.</p>
                    <p>In a multisig context, aside from secp256k1 keys, the number of keys provided in the attestation
                        is variable and
                        must meet the threshold as committed to in the hash computation and revealed in the attestation.
                    </p>
                    <p>When the address is generated, all public keys must be known in advance, and they must be sorted,
                        first by key
                        type, then by public key value, so as to be deterministic.</p>
                    <p>The key count does not need to be provided for PQC keys because the key type bitmask and
                        threshold are sufficient
                        to validate a multisig transaction.</p>
                    <p>In a singlesig context, multiple PQC keys can be provided, but the key type bitmask and threshold
                        must still also
                        be provided to be consistent with the multisig semantics. The threshold will be set as 0x01, and
                        the key type
                        bitmask will indicate how many keys of each type are present.</p>
                    <h3> Transaction Serialization </h3>
                    <p>Following BIP-141, a new transaction serialization format is introduced to include an attestation
                        field after the witness field:</p>
                    <pre><code>  [nVersion][marker][flag][txins][txouts][witness][attestation][nLockTime]
</code></pre>
                    <ul>
                        <li><code>marker</code>: <code>0x00</code> (same as SegWit)</li>
                        <li><code>flag</code>:
                            <ul>
                                <li><code>0x02</code> (indicates the presence of attestation data only)</li>
                                <li><code>0x03</code> (indicates the presence of both witness and attestation data)</li>
                            </ul>
                        </li>
                        <li><code>attestation</code>: Contains the quantum-resistant public keys and signatures.</li>
                    </ul>
                    <h3> Quantum Transaction ID (qtxid) </h3>
                    <p>The transaction ID is computed as the HASH256 of the serialized transaction, including the
                        attestation and witness
                        (if a witness is present). When decoded, this is called the qtxid, which will differ from the
                        txid and wtxid if an
                        attestation is present.</p>
                    <h3> Attestation Structure </h3>
                    <p>The attestation field consists of:</p>
                    <ul>
                        <li><code>key_type_bitmask</code>: A <a
                                href="https://learnmeabitcoin.com/technical/general/compact-size/"
                                target="_blank">compact size</a> value indicating which key types are present.</li>
                        <li><code>threshold</code>: A compact size value indicating the number of signatures required to
                            spend the output.</li>
                        <li><code>num_pubkeys</code>: The number of public keys (compact size).</li>
                    </ul>
                    <p>For each public key:</p>
                    <ul>
                        <li><code>key_type</code>: The key type (compact size). Only one bit is used to indicate the key
                            type.</li>
                        <li><code>pubkey_length</code>: compact size length of the public key (compact size).</li>
                        <li><code>pubkey</code>: The public key bytes.</li>
                    </ul>
                    <p>Then:</p>
                    <ul>
                        <li><code>num_signatures</code>: The number of signatures (compact size).</li>
                    </ul>
                    <p>For each signature:</p>
                    <ul>
                        <li><code>signature_length</code>: compact size length of the signature.</li>
                        <li><code>signature</code>: The signature bytes.</li>
                    </ul>
                    <p>This structure repeats for each input, in order, for flexibility in supporting multisig schemes
                        and various
                        quantum-resistant algorithms.</p>
                    <p>For each input, a separate attestation field is used. To know how many attestation fields are
                        present, implementations
                        must count the number of inputs present in the transaction.</p>
                    <h4> Attestation Parsing Example </h4>
                    <p>Signing for a single input using both secp256k1 Schnorr and FALCON-512:</p>
                    <p>Number of public keys:</p>
                    <pre><code>  [key_type_bitmask]: 0x03
  [threshold]: 0x01
  [num_pubkeys]: 0x02
</code></pre>
                    <p>Pubkey 1:</p>
                    <pre><code>  [key_type]: 0x01
  [pubkey_length]: 0x20 (32 bytes)
  [pubkey]: public_key_secp256k1
</code></pre>
                    <p>Pubkey 2:</p>
                    <pre><code>  [key_type]: 0x02
  [pubkey_length]: 0x0701 (1793 bytes)
  [pubkey]: public_key_falcon_512
</code></pre>
                    <p>Number of signatures:</p>
                    <pre><code>  [num_signatures]: 0x02
</code></pre>
                    <p>Signature 1:</p>
                    <pre><code>  [signature_length]: 0x40 (64 bytes)
  [signature]: signature_secp256k1
</code></pre>
                    <p>Signature 2:</p>
                    <pre><code>  [signature_length]: 0x0500 (1280 bytes)
  [signature]: signature_falcon_512
</code></pre>
                    <p>Note: This contrasts with multisig inputs, where the attestation structure repeats for each
                        public key and signature.</p>
                    <h3> Signature Algorithms </h3>
                    <p>The specific quantum-resistant signature algorithm used cannot be inferred from the length of the
                        public key due to
                        collisions in length between algorithms. Instead, when each key is revealed in the attestation,
                        the key type bitmask
                        indicates which algorithm was used.</p>
                    <p>Supported PQC algorithms and their NIST Level I parameters:</p>
                    <ul>
                        <li><strong>secp256k1 - BIP-340 - Schnorr + X-Only</strong>
                            <ul>
                                <li>Key Type 0</li>
                                <li>Public Key Length: 32 bytes</li>
                                <li>Signature Length: 64 bytes</li>
                                <li>Total Size: 96 bytes</li>
                                <li>Cycles to sign: 42,000 (EdDSA)</li>
                                <li>Cycles to verify: 130,000 (EdDSA)</li>
                            </ul>
                        </li>
                        <li><strong>FN-DSA-512 - FIPS 206 - FALCON-512:</strong>
                            <ul>
                                <li>Key Type 1</li>
                                <li>Public Key Length: 897 bytes</li>
                                <li>Signature Length: 667 bytes</li>
                                <li>Total Size: 1,564 bytes</li>
                                <li>Cycles to sign: 1,009,764</li>
                                <li>Cycles to verify: 81,036</li>
                            </ul>
                        </li>
                        <li><strong>ML-DSA-44 - FIPS 204 - CRYSTALS-Dilithium Level I:</strong>
                            <ul>
                                <li>Key Type 2</li>
                                <li>Public Key Length: 1,312 bytes</li>
                                <li>Signature Length: 2,420 bytes</li>
                                <li>Total Size: 3,732 bytes</li>
                                <li>Cycles to sign: 333,013</li>
                                <li>Cycles to verify: 118,412</li>
                            </ul>
                        </li>
                        <li><strong>SLH-DSA-SHAKE-128s - FIPS 205 - SPHINCS+-128s:</strong>
                            <ul>
                                <li>Key Type 3</li>
                                <li>Public Key Length: 32 bytes</li>
                                <li>Signature Length: 7,856 bytes</li>
                                <li>Total Size: 7,888 bytes</li>
                                <li>Cycles to sign: 4,682,570,992</li>
                                <li>Cycles to verify: 4,764,084</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Implementations must recognize the supported algorithms and validate accordingly.</p>
                    <p>A bitmask is used to indicate the algorithm used for each public key and signature pair. The
                        bitmask enumerates based on
                        the key type as indicated above. This is used in the cryptographic commitment in the hash
                        computation and
                        revealed in the attestation for each public key when spent.</p>
                    <h3> Script Validation </h3>
                    <p>To spend a P2QRH output, the following conditions must be met:</p>
                    <ol>
                        <li>The <code>scriptPubKey</code> must be of the form:</li>
                    </ol>
                    <p>OP_PUSHNUM_3 &lt;32-byte hash&gt;</p>
                    <ol start="2">
                        <li>The attestation must include:</li>
                    </ol>
                    <ul>
                        <li>The quantum-resistant public key(s) whose HASH256 concatenated and hashed again matches the
                            <nowiki>
                                <hash>
                            </nowiki> in</li>
                    </ul>
                    <p>the <code>scriptPubKey</code>.</p>
                    <ul>
                        <li>
                            <p>Valid signatures corresponding to the public key(s) and the transaction data.</p>
                        </li>
                        <li>
                            <p>The key type bitmask and threshold must match the commitment in the
                                <code>scriptPubKey</code>.</p>
                        </li>
                    </ul>
                    <ol start="3">
                        <li>For multi-signature schemes, all required public keys and signatures must be provided for
                            that input within the
                            attestation. Public keys that are not needed or available can be selectively disclosed by
                            including their hash in the
                            attestation accompanied with an empty signature by providing a 0x00 signature length byte.
                            This works so long as
                            enough keys to meet the threshold are provided.</li>
                    </ol>
                    <h4> Sighash Calculation </h4>
                    <p>The sighash for P2QRH outputs follows the same procedure as defined in <a href="/341"
                            target="_blank">BIP-341</a> for Taproot transactions:</p>
                    <ul>
                        <li><strong>Signature Message:</strong> A single-SHA256 of a tagged hash with the tag
                            "TapSighash", containing transaction data.</li>
                        <li><strong>Tagged Hash:</strong> Computed as H(tag || tag || data) where H is SHA256 and tag is
                            the SHA256 of the tag name.</li>
                        <li><strong>Key Data:</strong> In addition to transaction data, the sighash includes the spent
                            output's scriptPubKey.</li>
                        <li><strong>Extension Fields:</strong> Specific data is included or excluded from the sighash
                            based on the sighash flag.</li>
                    </ul>
                    <p>This signature hash construction ensures transaction malleability is prevented while providing
                        flexibility through
                        different sighash types (DEFAULT, ALL, NONE, SINGLE, and ANYONECANPAY variants). The exact
                        computation follows the
                        procedure specified in BIP-341 to maintain compatibility with Taproot signatures.</p>
                    <p>If a sighash flag other than DEFAULT is needed, it can be placed in the transaction witness. In
                        this case, it will be
                        the only field in the witness.</p>
                    <h4> Signature Verification </h4>
                    <p>Signature verification is as follows:</p>
                    <ol>
                        <li>
                            <p>Extract the <nowiki>
                                    <hash>
                                </nowiki> from the <code>scriptPubKey</code>.</p>
                        </li>
                        <li>
                            <p>For each input:</p>
                        </li>
                    </ol>
                    <ul>
                        <li>
                            <p>Compute <code>hashed_pubkeys</code> as specified in the Hash Computation section.</p>
                        </li>
                        <li>
                            <p>Compare the resulting hash to <nowiki>
                                    <hash>
                                </nowiki>. If they do not match, the script fails.</p>
                        </li>
                    </ul>
                    <ol start="3">
                        <li>
                            <p>Verify each signature against the corresponding public key and the sighash.</p>
                        </li>
                        <li>
                            <p>Ensure that the signature algorithm used matches the expected lengths for NIST Level I
                                security, and is supported by
                                the implementation.</p>
                        </li>
                    </ol>
                    <h3> Compatibility with BIP-141 </h3>
                    <p>By adhering to the SegWit transaction structure and versioning, P2QRH outputs are compatible with
                        existing transaction
                        processing rules. Nodes that do not recognize SegWit version 3 will treat these outputs as
                        anyone-can-spend but, per
                        <a href="/141" target="_blank">BIP-141</a>, will not relay or mine such transactions.
                    </p>
                    <h3> Usage Considerations </h3>
                    <h4> Transaction Size and Fees </h4>
                    <p>Quantum-resistant signatures are significantly larger than traditional signatures, increasing
                        transaction size and the
                        fees required. Users and wallet developers should be aware of this and plan accordingly.</p>
                    <p>For example, for CRYSTALS-Dilithium Level I, a single public key is 1,312 bytes, and a signature
                        is 2,420 bytes, resulting in a substantial increase over current
                        ECDSA or Schnorr signatures.</p>
                    <h4> Performance Impact </h4>
                    <p>Verification of quantum-resistant signatures will be computationally more intensive, and any
                        attestation discount will
                        also increase storage requirements. Node operators should consider the potential impact on
                        resource usage in the long
                        term. Developers may need to optimize signature verification implementations, especially by
                        implementing caching for
                        key generation.</p>
                    <h4> Algorithm Selection </h4>
                    <p>Introducing three quantum-resistant algorithms to the Bitcoin ecosystem provides users with the
                        option to select an
                        appropriate algorithm for their use case, generally based on the amount of value they wish to
                        secure. Developers can
                        choose to implement support for multiple algorithms in wallets and on nodes to offer
                        quantum-resistant options.</p>
                    <h4> Backward Compatibility </h4>
                    <p>Older wallets and nodes that have not been made compatible with SegWit version 3 and P2QRH will
                        not recognize these
                        outputs. Users should ensure they are using updated wallets and nodes to use P2QRH addresses and
                        validate transactions
                        using P2QRH outputs.</p>
                    <h2> Security </h2>
                    <table>
                        <thead>
                            <tr>
                                <th>+ Candidate quantum-resistant signature algorithms ordered by largest to smallest
                                    NIST Level V signature size</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Signature Algorithm</td>
                            </tr>
                            <tr>
                                <td><a href="https://en.wikipedia.org/wiki/Lamport_signature" target="_blank">Lamport
                                        signature</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://eprint.iacr.org/2011/191.pdf" target="_blank">Winternitz
                                        signature</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://sphincs.org/data/sphincs+-r3.1-specification.pdf"
                                        target="_blank">SPHINCS+ Rd. 3.1 (FIPS 205 - SLH-DSA)</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://eprint.iacr.org/2011/484.pdf" target="_blank">XMSS</a>
                                    <ref name="xmss">XMSS, which is based on Winternitz, uses a value of 108
                                </td>
                            </tr>
                            <tr>
                                <td><a href="https://pq-crystals.org/dilithium/" target="_blank">CRYSTALS-Dilithium
                                        (FIPS 204 - ML-DSA)</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://eprint.iacr.org/2014/457.pdf" target="_blank">pqNTRUsign</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://falcon-sign.info" target="_blank">FALCON (FIPS 206 - FN-DSA)</a>
                                </td>
                            </tr>
                            <tr>
                                <td><a href="https://eprint.iacr.org/2022/1155.pdf" target="_blank">HAWK</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://sqisign.org" target="_blank">SQIsign</a></td>
                            </tr>
                            <tr>
                                <td><a href="https://eprint.iacr.org/2024/760.pdf" target="_blank">SQIsign2D-West</a>
                                </td>
                            </tr>
                            <tr>
                                <td><a href="https://eprint.iacr.org/2023/436.pdf" target="_blank">SQIsignHD</a></td>
                            </tr>
                        </tbody>
                    </table>
                    <p>As shown, supersingular elliptic curve quaternion isogeny signature algorithms represent the
                        state of the art in
                        post-quantum cryptography, beyond lattice cryptography alone, especially when key and signature
                        length are major
                        constraints. This makes inclusion of SQIsign attractive, however its performance is roughly
                        100,000 times slower than ECC,
                        which is prohibitive in blockchain contexts. Meanwhile, SPHINCS+ and CRYSTALS-Dilithium
                        signatures are already approved
                        and have achieved broader community consensus. FALCON signatures are also NIST approved.</p>
                    <p>In comparison, the size of currently used signature algorithms are:</p>
                    <ul>
                        <li>ECDSA: 70-72 bytes</li>
                        <li>Schnorr: 64 bytes</li>
                    </ul>
                    <p>In comparison to inception date, secp256k1 <a href="https://www.secg.org/SEC1-Ver-1.0.pdf"
                            target="_blank">was originally specified in 2000</a>.</p>
                    <p>One consideration for choosing an algorithm is its maturity. secp256k1 was already 8 years old by
                        the time it was
                        chosen as Bitcoin's curve. Isogeny cryptography when it was first introduced was broken over a
                        weekend.</p>
                    <p>Signature verification speed as it compares to Schnorr or ECDSA isn't seen as high a
                        consideration as signature size
                        due to block space being the primary fee constraint. As a P2QRH implementation materializes, a
                        benchmark will be added
                        for performance comparison.</p>
                    <p>An additional consideration is security level. Longer signature sizes provide more security. NIST
                        has standardized five
                        security levels for post-quantum cryptography. NIST security level I provides security
                        equivalent to 128-bit keys, and
                        security level V provides 256-bit security.</p>
                    <h2> Test Vectors and Reference Code </h2>
                    <p>TBD</p>
                    <h2> Related Work </h2>
                    <p>It is worth noting by way of comparison that
                        [https://ethresear.ch/t/how-to-hard-fork-to-save-most-users-funds-in-a-quantum-emergency/18901
                        Vitalik Buterin's
                        proposed solution] in an Ethereum quantum emergency is quite different from the approach in this
                        BIP. His plan involves
                        a hard fork of the chain, reverting all blocks after a sufficient amount of theft, and using
                        STARKs based on BIP-32
                        seeds to act as the authoritative secret when signing. These measures are deemed far too
                        heavy-handed for Bitcoin.</p>
                    <h2> References </h2>
                    <ul>
                        <li><a href="https://groups.google.com/g/bitcoindev/c/Aee8xKuIC2s/m/cu6xej1mBQAJ"
                                target="_blank">Mailing list discussion</a></li>
                        <li><a href="https://delvingbitcoin.org/t/proposing-a-p2qrh-bip-towards-a-quantum-resistant-soft-fork/956?u=cryptoquick"
                                target="_blank">Delving Bitcoin discussion</a></li>
                        <li><a href="https://bitcoinops.org/en/newsletters/2024/06/14/" target="_blank">Bitcoin Optech
                                newsletter</a></li>
                        <li><a href="https://bitcoinops.org/en/podcast/2024/06/18/"
                                target="_blank">draft-bip-for-quantum-safe-address-format Bitcoin Optech discussion
                                transcript</a></li>
                    </ul>
                    <h2> Footnotes </h2>
                    <references />
                    <h2> Changelog </h2>
                    <p>To help implementors understand updates to this BIP, we keep a list of substantial changes.</p>
                    <ul>
                        <li>2025-03-18 - Correct inconsistencies in commitment and attestation structure. Switch from
                            merkle tree commitment to sorted vector hash commitment. Update descriptor format.</li>
                        <li>2025-03-12 - Add verification times for each algorithm. 256 -&gt; 128 (NIST V -&gt; NIST I).
                            Add key type bitmask. Clarify multisig semantics.</li>
                        <li>2025-02-23 - More points of clarification from review. Update dead link.</li>
                        <li>2025-01-20 - Remove SQIsign from consideration due to significant performance concerns.
                            Refactor language from long-range attack to long-exposure so as to not be confused with the
                            language around block re-org attacks.</li>
                        <li>2024-12-18 - Assigned BIP number.</li>
                        <li>2024-12-13 - Update to use merkle tree for attestation commitment. Update LR &amp; SR
                            quantum attack scenarios.</li>
                        <li>2024-12-01 - Add details on attestation structure and parsing.</li>
                        <li>2024-10-21 - Replace XMSS with CRYSTALS-Dilithium due to NIST approval and size constraints.
                        </li>
                        <li>2024-09-30 - Refactor the ECC vs PoW section. Swap quitness for attestation.</li>
                        <li>2024-09-29 - Update section on PoW to include partial-preimage.</li>
                        <li>2024-09-28 - Add Winternitz, XMSS signatures, and security assumption types to PQC table.
                            Omit NIST Level I table. Add spend script specification. Add revealed public key scenario
                            table.</li>
                        <li>2024-09-27 - Initial draft proposal</li>
                    </ul>
                    <h2> Acknowledgements </h2>
                    <p>This document is inspired by <a href="/341" target="_blank">BIP-341</a>, which introduced
                        the design of the P2TR (Taproot) output type using Schnorr signatures.</p>
                    <p>Much gratitude to my co-founder, Kyle Crews for proofreading and editing, to David Croisant, who
                        suggested the name
                        "QuBit", and Guy Swann for pointing out the earlier name for the attestation, "quitness", was
                        imperfect. Thank you as
                        well to those who took the time to review and contribute, including Jeff Bride, Adam Borcany,
                        Antoine Riard, Pierre-Luc
                        Dallaire-Demers, Ethan Heilman, Jon Atack, Jameson Lopp, Murchandamus, and Vojtฤch Strnad.</p>

                </article>
            </div>


            <hr class="border-slate-700" />

            <div data-pagefind-ignore class="w-full flex flex-col items-center space-y-2 text-center">
                <div class="flex items-center space-x-2">
                    <p class="font-bold">Updated:</p>
                    <p class="font-bold">May 2025</p>
                </div>

                <p class="pt-4 text-sm">All content is owned and licensed by the respective author(s). This website
                    makes no claim of ownership.</p>
            </div>
        </div>
    </div>

</html>